<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Fuyk&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Fuyk&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fuyk&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Fuyk's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fuyk's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/以太坊公私钥和地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/以太坊公私钥和地址/" itemprop="url">以太坊公私钥和地址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T00:35:05+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://www.jianshu.com/p/b7fea05ab44a" target="_blank" rel="noopener">《精通以太坊》-密钥，地址</a></p>
<p><a href="http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/" target="_blank" rel="noopener">【Ethereum基础】：账户、地址、私钥和公钥</a></p>
<p><a href="https://www.jianshu.com/p/d484369d08b4" target="_blank" rel="noopener">以太坊账户地址编码大小写问题</a></p>
<p><a href="https://blog.csdn.net/shebao3333/article/details/80043317" target="_blank" rel="noopener">如何判断一个以太坊地址是不是合约</a></p>
<p><a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener">ethereum yellow paper</a></p>
<h2 id="私钥生成"><a href="#私钥生成" class="headerlink" title="私钥生成"></a>私钥生成</h2><p>secp256k1椭圆曲线算法生成私钥。</p>
<h2 id="公钥生成"><a href="#公钥生成" class="headerlink" title="公钥生成"></a>公钥生成</h2><p>从私钥导出</p>
<h2 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h2><p>对公钥做 Keccak-256 哈希，取得结果的最后 40 位 16 进制字符即为地址。</p>
<h2 id="地址有效性检测"><a href="#地址有效性检测" class="headerlink" title="地址有效性检测"></a>地址有效性检测</h2><p>可通过 geth 控制台以下命令检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.utils.isAddress(&quot;0x1111...111&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="noopener">EIP 55 规范</a>：对账户地址求keccak256哈希运算，根据运算结果值的二进制位图决定地址十六进制字符串（0-9，a-f）的大写或小写。</li>
</ul>
<h2 id="检测地址类型"><a href="#检测地址类型" class="headerlink" title="检测地址类型"></a>检测地址类型</h2><ul>
<li><p>web3.eth.getCode() 方法返回指定地址上代码的16进制字符串，由于普通账户地址处没有代码，因此将仅返回16进制前缀 <code>0x</code></p>
</li>
<li><p>solidity 中，可以使用EVM汇编代码来获取指定地址处的代码大小，显然，普通账户地址将返回 <code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract EzDemo &#123;</span><br><span class="line">    function isContract(address addr) returns (bool) &#123;</span><br><span class="line">    uint size;</span><br><span class="line">    assembly &#123; size := extcodesize(addr) &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line">作者：新缸中之脑 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/shebao3333/article/details/80043317 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="合约地址生成"><a href="#合约地址生成" class="headerlink" title="合约地址生成"></a>合约地址生成</h2><p>根据黄皮书：</p>
<blockquote>
<p>The address of the new account is defined as being the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and the account nonce.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/solidity-contracts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/solidity-contracts/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T00:14:39+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Contracts"><a href="#Contracts" class="headerlink" title="Contracts"></a>Contracts</h1><hr>
<p>title: solidity contracts</p>
<p>date: 2018-3-12 15:40:33</p>
<p>tags: blockchain ethereum solidity contract</p>
<hr>
<p>Solidity 中的合约与面向对象语言中的类相似。它们拥有持久化的状态变量，和可以修改这些变量的函数。在不同的合约（实例）上调用函数将执行 EVM 函数调用，从而切换上下文使得状态变量不可访问。</p>
<h2 id="Creating-Contracts"><a href="#Creating-Contracts" class="headerlink" title="Creating Contracts"></a>Creating Contracts</h2><p>合约可以通过以太坊 “从外部” 创建，或者在 Solidity 中被创建。</p>
<p>IDE，如 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>，使用 UI 元素来使得创建过程十分友好。</p>
<p>在以太坊上编程创建合约最好通过 JavaScript API 的 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>。目前，它有一个名为 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a> 的方法来方便创建合约。</p>
<p>在合约创建时，它的构造函数（和合约具有同名的函数）会被执行一次。构造函数是可选的。只允许存在一个构造函数，即不支持对构造函数的重载。</p>
<p>在内部，构造函数的参数按照 <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html#abi" target="_blank" rel="noopener">ABI 来编码</a> 然后在合约本身的代码之后传递，如果你使用的是 <code>web3.js</code>，就不用关心这一点。</p>
<p>如果一个合约想要创建另一合约，创建者需要知道被创建的合约的源代码（和二进制代码）。这也说明循环依赖是不可能的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">	TokenCreator creator;</span><br><span class="line">	address owner;</span><br><span class="line">	bytes32 name;</span><br><span class="line"></span><br><span class="line">	function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">		owner = msg.sender;</span><br><span class="line">		creator = TokenCreator(msg.sender);</span><br><span class="line">		name = _name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function changeName(bytes32 newName) public &#123;</span><br><span class="line">		if (msg.sender == address(creator))</span><br><span class="line">			name = newName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function transfer(address newOwner) public &#123;</span><br><span class="line">		if (msg.sender != owner) return;</span><br><span class="line">		if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">			owner = newOwner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">	function createToken(bytes32 name) public returns(OwnedToken tokenAddress) &#123;</span><br><span class="line">		return new OwnedToken(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function changeName(OwnedToken tokenAddress, bytes32 name) public &#123;</span><br><span class="line">		tokenAddress.changeName(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function isTokenTransferOK(address currentOwner, address newOwner) public view returns (bool ok) &#123;</span><br><span class="line">		address tokenAddress = msg.sender;</span><br><span class="line">		return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Visibility-and-Getters"><a href="#Visibility-and-Getters" class="headerlink" title="Visibility and Getters"></a>Visibility and Getters</h2><p>solidity 有两种函数调用（不会创建一个真实虚拟机调用（也被称作消息调用）的内部调用，以及会创建一个真实的虚拟机调用的外部调用），函数和状态变量则有 4 种可见性。</p>
<p>函数可以被指定为，<code>external / public / internal / private</code>，默认值为 <code>public</code>。对于状态变量来说，<code>external</code> 是不可能的，默认值为 <code>internal</code>。</p>
<p><code>external</code>：</p>
<p>外部函数是合约接口的一部分，这表示它们可以被其他合约或者通过交易来调用。一个外部函数 <code>f</code> 不能在内部被调用（即 <code>f()</code> 不会起作用，而 <code>this.f()</code> 会）。外部函数在接收大量的数组数据时更有效率。</p>
<p><code>public</code>：</p>
<p>公有函数是合约接口的一部分，既可以被内部调用也可以通过消息被调用。对于状态变量来说，会生成一个自动获取函数。</p>
<p><code>internal</code>：</p>
<p>这些函数和状态变量只能被内部访问（即在当前的合约内或者继承了当前合约的合约），使用时不需要 <code>this</code>。</p>
<p><code>private</code>：</p>
<p>私有函数和状态变量只能在其被定义的合约内使用，即使是在子合约中也不可以被使用。</p>
<p>（<code>public / internal / private</code> 相当于面向对象的 <code>public / protected / private</code>，<code>external</code> 的作用是限制函数只能在外部被使用。）</p>
<p>注意：合约内的任何内容都可以被外界看到。<code>private</code> 只是防止了其他合约访问和修改该私有信息，但是它依旧可以被区块链之外的整个世界看到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	function f(uint a) private pure returns (uint b) &#123;</span><br><span class="line">		return a + 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">	uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下面的例子中，<code>D</code>，可以调用 <code>c.getData()</code> 来获取状态存储中 <code>data</code> 的值，但是不能调用 <code>f</code>。合约 <code>E</code> 继承了 <code>C</code>，所以可以调用 <code>compute</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	uint private data;</span><br><span class="line"></span><br><span class="line">	function f(uint a) private returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">	function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">	function getData() public returns (uint) &#123; return data; &#125;</span><br><span class="line">	function compute(uint a, uint b) internal returns (uint) &#123; return a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">	function readData() public &#123;</span><br><span class="line">		C c = new C();</span><br><span class="line">		uint local = c.f(7);</span><br><span class="line">		c.setData(3);</span><br><span class="line">		local = c.getData();</span><br><span class="line">		local = c.compute(3, 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">	function g() public &#123;</span><br><span class="line">		C c = new C();</span><br><span class="line">		uint val = compute(3, 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取器函数"><a href="#获取器函数" class="headerlink" title="获取器函数"></a>获取器函数</h3><p>编译器会为所有的 <code>public</code> 状态变量创建获取器函数。对于下面给出的合约，编译器会生成一个叫 <code>data</code> 的方法，该方法不需要任何参数，会返回一个类型为 <code>uint</code> 的状态变量 <code>data</code> 的值。状态变量的初始化会在定义的时候执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">	C c = new C();</span><br><span class="line">	function f() public &#123;</span><br><span class="line">		uint local = c.data();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取器方法拥有外部可见性。如果该标识符在内部被访问（即不是使用 <code>this.</code>），它会被当做一个状态变量。如果它在外部被访问（即使用 <code>this.</code>），它会被当做一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	uint public data;</span><br><span class="line">	function x() public &#123;</span><br><span class="line">		data = 3;</span><br><span class="line">		uint val = this.data();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下个例子更复杂一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">	struct Data &#123;</span><br><span class="line">		uint a;</span><br><span class="line">		bytes3 b;</span><br><span class="line">		mapping (uint =&gt; uint) map;</span><br><span class="line">	&#125;</span><br><span class="line">	mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会生成一个下列格式的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">	a = data[arg1][arg2][arg3].a;</span><br><span class="line">	b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，结构体中的映射被省略了，因为这里没有好办法来为映射提供键。</p>
<h2 id="Function-Modifiers"><a href="#Function-Modifiers" class="headerlink" title="Function Modifiers"></a>Function Modifiers</h2><p>可以很容易地使用修饰器来修改函数的行为。例如，它可以自动在执行函数之前检查条件。修饰器是合约的可继承属性，而且可以被子合约覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">	funcion owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">	address owner;</span><br><span class="line"></span><br><span class="line">	modifier onlyOwner &#123;</span><br><span class="line">		require(msg.sender == owner);</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">	function close() public onlyOwner &#123;</span><br><span class="line">		selfdestruct(owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">	modifier costs(uint price) &#123;</span><br><span class="line">		if (msg.value &gt;= price) &#123;</span><br><span class="line">			_;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">	mapping(address =&gt; bool) registeredAddresses;</span><br><span class="line">	uint price;</span><br><span class="line"></span><br><span class="line">	function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">	function register() public payable costs(price) &#123;</span><br><span class="line">		registeredAddresses[msg.sender] = true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">		price = _price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">	bool locked;</span><br><span class="line">	modifier noReentrancy() &#123;</span><br><span class="line">		require(!locked);</span><br><span class="line">		locked = true;</span><br><span class="line">		_;</span><br><span class="line">		locked = false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">		require(msg.sender.call());</span><br><span class="line">		return 7;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在一个空白分隔的列表中指定多个修饰符并按照所呈现的顺序对多个修饰符进行判断。</p>
<p>警告：在 Solidity 的早期版本中，拥有修饰器的函数中的 <code>return</code> 语句的行为是不同的。</p>
<p>修饰器或者函数体中显式的 <code>return</code> 只会离开当前的修饰器或者函数体。返回变量被赋值并且控制流程在前一个修改器中的“<code>_</code>”之后继续。</p>
<p>允许任意表达式用于修饰符参数，在此上下文中，该函数中的所有可见的符号在修饰器中同样可见。而在修饰器中的引入的符号，在函数中并不可见（因为他们可能会被通过覆盖来更改）。</p>
<h2 id="Constant-State-Variables"><a href="#Constant-State-Variables" class="headerlink" title="Constant State Variables"></a>Constant State Variables</h2><p>状态变量可以被定义为 <code>constant</code>。在这个例子中，它们必须被一个在编译时是常数的表达式所赋值。所有访问存储，区块链数据（如 <code>now</code>，<code>this.balance</code> 或者 <code>block.number</code>）或者执行数据（<code>msg.gas</code>）或者禁止外部调用合约的表达式。对内存分配有影响的表达式也被允许，但是对其他内存对象产生印象的表达式是不可以的。内置函数 <code>keccak256 / sha256 / ripemd160 / ecrecover / addmod / mulmod</code> 是被允许的（即使它们调用了外部合约）。</p>
<p>允许对内存分配有影响是因为它应该可以构造一个复杂的对象，如 查找表。目前为止，这个特性并不能完全使用。</p>
<p>编译器不会为这些变量保留一个存储槽，并且每个出现都被各自的常量表达式（可能由优化器计算为单个值）替换。</p>
<p>并非所有类型的常量都被实现了。唯一支持的类型是值类型和字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	uint constant x = 32 ** 22 + 8;</span><br><span class="line">	string constant text = &quot;abc&quot;;</span><br><span class="line">	bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="View-Functions-不会修改状态"><a href="#View-Functions-不会修改状态" class="headerlink" title="View Functions : 不会修改状态"></a>View Functions : 不会修改状态</h3><p>修改状态的语句：</p>
<ol>
<li>写入状态变量</li>
<li>发生事件</li>
<li>创建其他合约</li>
<li>使用 selfdestruct </li>
<li>通过调用发送 Ether</li>
<li>调用任何不是 view 和 pure 的方法</li>
<li>使用底层调用</li>
<li>使用大量行内的确定的 opcodes</li>
<li>constant 是 view 的别名</li>
<li>Getter 方法是 view 方法</li>
<li>目前为止，编译器并没有强制要求 view 不能修改状态</li>
</ol>
<h3 id="Pure-Function-：-不会读取或修改状态"><a href="#Pure-Function-：-不会读取或修改状态" class="headerlink" title="Pure Function ： 不会读取或修改状态"></a>Pure Function ： 不会读取或修改状态</h3><p>除了上述修改状态的语句，读取状态语句如下：</p>
<ol>
<li>读取状态</li>
<li>访问 <code>this.balance</code> 或 <code>&lt;address&gt;.balance</code></li>
<li>访问 <code>block</code>, <code>tx</code>, <code>msg</code> 的任何成员（不包括 <code>msg.sig</code> 和 <code>msg.data</code>）</li>
<li>调用任何非 <code>pure</code> 方法</li>
<li>使用大量包含了确定的行内 <code>opcodes</code></li>
<li>目前为止，编译器没有强制要求 pure 方法不能读取状态</li>
</ol>
<h3 id="Fallback-Function"><a href="#Fallback-Function" class="headerlink" title="Fallback Function"></a>Fallback Function</h3><p>一个合约可以拥有一个没有名字的方法。该方法不能有参数和返回。如果调用了该合约不存在的方法，或者没有提供数据，就会执行这个方法。</p>
<p>当合约收到没有数据的转账时，这个方法就会执行。为了接受以太坊，fallback function 必须标记为 <code>payable</code>。如果不存在该方法，合约就无法通过常规的交易收到以太币。</p>
<p>这样的情境中，调用该方法只会消耗极少量的 gas（精确的说是 2300 gas），所以使 fallback 函数尽可能的便宜是十分重要的。注意通过交易（不是内部调用）调用 fallback 函数会消耗更多 gas，因为每笔交易都会需要额外的 21000 gas 或者更多的消耗，如果还有其他操作比如检查签名。</p>
<p>以下操作比 fallback 函数消耗的 gas 会更多：</p>
<ol>
<li>写入存储</li>
<li>创建合约</li>
<li>调用一个消耗大量 gas 的外部方法</li>
<li>发送以太币</li>
</ol>
<p>在部署合约之前，彻底的测试一下，确认 fallback 函数的执行消耗少于 2300 gas。</p>
<ul>
<li>即使 fallback 函数不能有参数，但是还是可以通过 msg.data 来获取任何调用该函数时提供的数据。</li>
<li>如果没有定义 fallback 函数，而是直接接收 Ether（没有使用函数调用，即使用 <code>send</code> 或者 <code>transfer</code>），会抛出一个异常，然后 Ether 会回退（这点和 solidity v0.4.0 之前不同）。所以如果你想要你的合约收到 Ether，就必须实现一个 fallback 函数。</li>
<li>没有 payable fallback 函数来接收 Ether 的话，合约可以通过 coinbase 来接收挖矿奖励来获得 Ether，或者作为自销毁的目标（destination of a selfdestruct）。<br>合约不会对这样的 Ether 转账做出反应，所以自然也不能拒绝。这是 EVM 的一个设计选择，而 Solidity 并不能在这方面工作。<br>这也表示，<code>this.balance</code> 可以比在合约中实现的手工账户总量要高（即在 fallback 函数中有一个更新的计数器）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">	function() public &#123; x = 1; &#125;</span><br><span class="line">	uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Sink &#123;</span><br><span class="line">	function() public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">	function callTest(Test test) public &#123;</span><br><span class="line">		test.call(0xabcdef01);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-Overloading"><a href="#Function-Overloading" class="headerlink" title="Function Overloading"></a>Function Overloading</h3><p>一个合约可以拥有多个同名但不同参数的函数，这也适用于继承的方法。下面的例子展示了在合约 A 内重载了 <code>f</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">	function f(uint _in) public pure returns (uint out) &#123;</span><br><span class="line">		out = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function f(uint _in, bytes32 _key) public pure returns (uint out) &#123;</span><br><span class="line">		out = 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载方法也可以存在于外部接口。如果两个外部可见的方法，它们的 solidity 类型不同，但它们的外部类型相同，就会报一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// this will not compile</span><br><span class="line">pragma solidity ^0.4.16</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">	function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">		out = _in;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">		out = _in;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个 <code>f</code> 函数重载最终都会接受ABI的地址类型，尽管它们在 Solidity 中被认为是不同的。</p>
<h3 id="重载方式-和-参数匹配"><a href="#重载方式-和-参数匹配" class="headerlink" title="重载方式 和 参数匹配"></a>重载方式 和 参数匹配</h3><p>通过将当前作用域中的函数声明与函数调用中提供的参数进行匹配来选择重载函数。 如果所有参数都可以隐式转换为预期的类型，则函数被选为重载候选项。 如果找不到，则失败。</p>
<ul>
<li>返回的参数不会影响重载。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">	function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">		out = _in;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	funciton f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">		out = _in;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>f(50)</code> 会产生一个类型错误，因为 <code>250</code> 可以被隐式转换成 <code>uint8</code> 和 <code>uint256</code> 类型。另一方面 <code>f(256)</code> 会被当做 <code>f(uint256)</code> 来重载，因为 <code>256</code> 不能被隐式替换为 <code>uint8</code>。</p>
<h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>事件允许方便地使用 EVM 日志记录工具，后者又可用于“调用”监听这些事件的 dapp 的用户界面中 JavaScript 回调。</p>
<p>事件可被继承。调用它们的时候，它们会将参数存储在交易日志中，交易日志是区块链中一个特殊的数据结构。这些日志会和合约的地址关联起来，然后被存入区块链中，只要区块能够被访问，日志就会一直存在。日志和事件数据并不能在合约内访问到，即使是创建它们的合约也不行。</p>
<p>对日志的 SPV 证明的可能的，如果存在一个外部的实体提供了一个有这样的证明的合约，它就可以查看在区块链中的确实存在的日志。不过要注意的是必须提供区块头，因为合约只能看到最后的 256 个区块的哈希。</p>
<p>最多三个参数可以接受 indexed 属性，该属性可以让这些参数被独立搜索，这样就可以在用户接口中获取指定索引参数的详细值。</p>
<p>如果在索引参数中使用了数组（包含了 string 和 bytes），那么它的 Keccak-256 哈希会被存为话题。</p>
<p>事件的签名哈希是诸多话题中的一个，除非你对事件声明了 anonymous。这说明过通过名字滤出 anonymous 事件的详细信息是不可能的。<br>​<br>所有非索引参数会作为日志数据的一部分存储。</p>
<ul>
<li>索引参数不能存储它们本身。只能搜索值，而不能获得这些值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">	event Deposit(</span><br><span class="line">		address indexed _from,</span><br><span class="line">		bytes32 indexed _id,</span><br><span class="line">		uint _value</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">		emit Deposit(msg.sender, _id, msg.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript API 中的使用方法如下，通过合约的 abi 和地址获取到合约的实例，然后获取到事件，然后监听该事件，当该事件被触发，进行后续操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler*/;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">event.watch(function(error, result) &#123;</span><br><span class="line">	if (!error)</span><br><span class="line">		console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">	if (!error)</span><br><span class="line">		console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Low-Level-Interface-to-Logs"><a href="#Low-Level-Interface-to-Logs" class="headerlink" title="Low-Level Interface to Logs"></a>Low-Level Interface to Logs</h3><p>可以通过方法 log0, log1, log2, log3, log4 来访问日志机制的底层接口。logi 使用第 i + 1 个 bytes32 类型的参数，第一个参数将会作为日志数据的一部分，其他作为话题。上述事件使用方式一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 16 进制为事件的签名 keccak256(“Deposit(address,hash256,uint256)”)。</p>
<h3 id="其他理解事件的资源"><a href="#其他理解事件的资源" class="headerlink" title="其他理解事件的资源"></a>其他理解事件的资源</h3><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">Javascript documentation</a></li>
<li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol" target="_blank" rel="noopener">Example usage of events</a></li>
<li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js" target="_blank" rel="noopener">How to access them in js</a></li>
</ul>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>Solidity 使用复制代码，包括多态来支持多重继承。</p>
<p>所有的函数调用都是虚拟的，意思是几乎所有的继承的函数都被调用，除了合约名字被显式指定的时候。（All function calls are virtual, which means that the most derived function is called, except when the contract name is explicitly given.）</p>
<p>当一个合约继承了多个合约，只有一个合约在区块链上被创建，继承的代码会被复制到创建的合约中。</p>
<p>常规的继承系统和 Python 的十分相似，特别是多重继承。</p>
<p>细节可见下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16</span><br><span class="line"></span><br><span class="line">contract owner &#123;</span><br><span class="line">	function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">	address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">	function kill() &#123;</span><br><span class="line">		if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Config &#123;</span><br><span class="line">	function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">	function register(bytes32 name) public;</span><br><span class="line">	function unregister() public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">	function named(bytes32 name) &#123;</span><br><span class="line">		Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">		NameReg(config.lookup(1)).register(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function kill() public &#123;</span><br><span class="line">		if (msg.sender == owner) &#123;</span><br><span class="line">			Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">			NameReg(config.lookup(1)).unregister();</span><br><span class="line">			mortal.kill();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">	function updateInfo(uint newInfo) public &#123;</span><br><span class="line">		if (msg.sender ==  owner) info = newInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function get() public view returns (uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">	uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在上面我们调用了 <code>mortal.kill()</code> 来“推进”销毁请求。这个方法是有问题的，见下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">	function owned() public &#123; owned = msg.sender; &#125;</span><br><span class="line">	address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">	function kill() public &#123;</span><br><span class="line">		if (msg.sender == owned) selfdestruct(owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">	function kill() public &#123; mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">	function kill() public &#123; mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>Final.kill()</code> 的调用会调用 <code>Base2.kill</code> 作为重写，但是这个方法会忽略 <code>Base1.kill</code>，主要是因为它甚至不知道 <code>Base1</code>。解决方法是使用 <code>super</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">	function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">	address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">	function kill() public &#123;</span><br><span class="line">		if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">	function kill() public &#123;super.kill();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">	function kill() public &#123;super.kill();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Base2</code> 调用了一个 <code>super</code> 函数，它不是简单地调用它父合约的该方法。相反，它调用在最终继承图中的下一个父合约的该函数，所以它会调用 <code>Base1.kill()</code>（注意最终的继承序列是 - 从最后派生的合约开始：Final, Base2, Base1, mortal, owned）。使用 <code>super</code> 调用的函数，在它使用的上下文情境中，其实并不知道是哪个，虽然它的类型是已知的。这和普通的虚函数查找是类似的。</p>
<h3 id="Arguments-for-Base-Constructors"><a href="#Arguments-for-Base-Constructors" class="headerlink" title="Arguments for Base Constructors"></a>Arguments for Base Constructors</h3><p>派生合约需要提供父合约构造器所需要的所有参数。可以通过以下两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">	uint x;</span><br><span class="line">	function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">	function Derived(uint _y) Base(_y * _y) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个方式是直接在继承列表中（<code>is Base(7)</code>）。另一种方式是调用一个修饰符作为派生构造函数的头部的一部分 <code>(Base(_y * _y))</code>。如果构造函数参数是一个常量，并且定义了合约的行为或者描述了它，第一个方法会更方便。第二种方法在父合约的构造函数的参数依赖派生合约的时候使用。在上面这个很蠢的例子中，两个地方都使用了，那么修饰器形式的参数有更高的优先级。</p>
<h3 id="Multiple-Inheritance-and-Linearization"><a href="#Multiple-Inheritance-and-Linearization" class="headerlink" title="Multiple Inheritance and Linearization"></a>Multiple Inheritance and Linearization</h3><p>允许多重继承的语言必须解决一些问题。一个是<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">菱形问题(<code>Diamond Problem</code>)</a>。Solidity 遵循 Python 的路径，并使用 <a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener">C3 Linearization</a> 来强制基类中 DAG 的详细顺序。这导致了单调性的理想特性，但不允许某些继承图。特别的，通过 <code>is</code> 命令给出的基类内的顺序是十分重要的。在下列的代码中，Solidity 会给出一个错误 ”Linearization of inheritance graph impossible“</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// this will not compile</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>原因是 <code>C</code> 要求 <code>X</code> 重写 <code>A</code>(通过指定 <code>A, X</code> 顺序)，但是 <code>A</code> 本身又会请求重写 <code>X</code>，这就是个不能解决的矛盾了。</p>
<p>一个简单记住的规则是具体描述基类的顺序从 ”最基础的“ 到 ”最多派生的“（大概就是从后往前，从最后的合约，到最开始的原始被继承的合约）。</p>
<h3 id="Inheriting-Different-Kinds-of-Members-of-the-Same-Name"><a href="#Inheriting-Different-Kinds-of-Members-of-the-Same-Name" class="headerlink" title="Inheriting Different Kinds of Members of the Same Name"></a>Inheriting Different Kinds of Members of the Same Name</h3><p>当继承导致了一个合约内有同名的函数和修饰器，它会被视作一个错误。同名事件和修饰器，同名函数和事件也都会导致这个错误。例外的是，一个状态变量的获取器可以被一个公开的方法重写。</p>
<h2 id="Abstract-Contracts"><a href="#Abstract-Contracts" class="headerlink" title="Abstract Contracts"></a>Abstract Contracts</h2><p>合约函数可以缺少具体的实现方式，例子如下（注意函数声明头以 <code>;</code> 结束）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">	function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的合约是不能编译的（即使有别的方法已经有具体的实现方式了），但是它可以作为父合约来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">	function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">	function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个合约继承了一个抽象合约，但是没有完全实现那些未实现的函数，那么它也会成为一个抽象合约。</p>
<p>注意一个没有实现的方法与 <a href="https://solidity.readthedocs.io/en/develop/types.html#function-types" target="_blank" rel="noopener">方法类型</a> 是不同的，即使它们的语法看起来十分相似。</p>
<p>未实现的函数示例（一个函数声明）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(address) external returns (address);</span><br></pre></td></tr></table></figure>
<p>函数类型示例（一个变量的声明，其类型为 <code>function</code>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(address) external returns (address) foo;</span><br></pre></td></tr></table></figure>
<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口和抽象合约十分相似，但是它不能有任何的方法实现。这里是一些更严格的限制：</p>
<ol>
<li>不能继承其他合约或者接口</li>
<li>不能定义构造函数</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义 <code>enums</code></li>
</ol>
<p>这些限制中的一部分可能在将来会被取消掉。</p>
<p>接口基本上的仅限于合约 abi 所表达的内容，而它们之间应该是能够转换而不损失任何信息的。</p>
<p>接口通过它们自身的关键词表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">	funciton transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合约可以和继承其他合约一样继承接口。</p>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><p>类库和合约十分相似，但是它们的目的是只被部署在指定的地址上一次，而它们的代码会通过以太坊虚拟机的 <code>DELEGATECALL</code> （Homestead 之前是 <code>CALLCODE</code>）来重复使用。这个意思就是如果类库函数被调用，它们的代码就会在调用它的合约上下文中执行，即 <code>this</code> 指向发起调用的合约，并且发起调用的合约的存储能够被访问。作为类库，它们是从源码中剥离出来的片段，如果发起调用的合约显式地提供了状态变量，那么类库只能访问调用合约的这些状态变量（但是它不能命名这些变量）。因为类库被假定为无状态，所以如果类库函数不修改状态的话（即它们是 <code>view / pure</code> 函数），那么它们只能被直接调用（即不通过 <code>DELEGATECALL</code>）。特别的，除非绕过了 Solidity 的类型系统，否则不可能破坏类库。</p>
<p>类库可以被当做是那些使用类库的合约的父合约。它们在继承层次结构中并不是显式可见的，但对库函数的调用看起来就像调用显式的父合约函数（如果类库名为 <code>L</code>，调用方式为 <code>L.f()</code>）。更多的，类库的 <code>internal</code> 函数是对所有合约可见的，就想类库是一个父合约一样。当然，调用内部函数就需要使用内部调用的方式，就是说所有的内部类型都可以被传递并且内存类型会通过引用传递而不是复制。为了在 EVM 中认识到这一点，内部类库函数的代码和所有被调用的函数会在编译时被拉入发起调用的合约内，并且将使用常规的 <code>JUMP</code> 调用而不是 <code>DELEGATECALL</code>。</p>
<p>下列例子描述了如何使用类库（但一定要查看<a href="https://solidity.readthedocs.io/en/develop/contracts.html#using-for" target="_blank" rel="noopener"><code>using for</code></a>来实现一组更高级的示例）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">	struct Data&#123;</span><br><span class="line">		mapping(uint =&gt; bool) flags;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function insert(Data storage self, uint value) public returns (bool) &#123;</span><br><span class="line">		if (self.flags[value])</span><br><span class="line">			reutrn false;</span><br><span class="line"></span><br><span class="line">		self.flags[value] = true;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function remove(Data storage self, uint value) public returns (bool) &#123;</span><br><span class="line">		if (!self.flags[value])</span><br><span class="line">			return false;</span><br><span class="line">		self.flags[value] = false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function contains(Data storage self, uint value) public view returns (bool) &#123;</span><br><span class="line">		return self.flags[value];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">	function register(uint value) public &#123;</span><br><span class="line">		require(Set.insert(knownValues, value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你不用遵循这个方式来使用类库：它们也可以不通过定义结构体数据类型来使用。没有任何存储引用参数，函数也可以正常工作，而且它可以在任何位置拥有多重的存储引用参数。</p>
<p>对 <code>Set.contains</code>，<code>Set.insert</code> 和 <code>Set.remove</code> 的调用，会被作为调用（<code>DELEGATECALL</code>）外部合约/类库来编译。如果你使用类库，注意执行实际的外部函数调用。尽管 <code>msg.sender</code>，<code>msg.value</code> 和 <code>this</code> 会在这个调用中保留它们的值（但是在 Homestead 之前，由于使用了 <code>CALLCODE</code>，<code>msg.sender</code> 和 <code>msg.value</code> 就改变了）。</p>
<p>下面的例子显示了如何在库中使用内存类型和内部函数，以实现自定义类型，而无需外部函数调用的开销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">	struct bigint &#123;</span><br><span class="line">		uint[] limbs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">		r.limbs = new uint[](1);</span><br><span class="line">		r.limbs[0] = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">		r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">		uint carry = 0;</span><br><span class="line">		for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">			uint a = limb(_a, i);</span><br><span class="line">			uint b = limb(_b, i);</span><br><span class="line">			r.limbs[i] = a + b + carry;</span><br><span class="line">			if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">				carry = 1;</span><br><span class="line">			else </span><br><span class="line">				carry = 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (carry &gt; 0) &#123;</span><br><span class="line">			uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">			for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">				newLimbs[i] = r.limbs[i];</span><br><span class="line">			newLimbs[i] = carry;</span><br><span class="line">			r.limbs = newLimbs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">		return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">		return a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">	function f() public pure &#123;</span><br><span class="line">		var x = BigInt.fromUint(7);</span><br><span class="line">		var y = BigInt.fromUint(uint(-1));</span><br><span class="line">		var z = x.add(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为编译器不可能做到类库被部署到那哪里，所以这些地址需要通过链接（见 <a href="https://solidity.readthedocs.io/en/develop/using-the-compiler.html#commandline-compiler" target="_blank" rel="noopener">Using the Commandline Compiler</a> 查看如何使用命令行编译器来链接）填充到最后的字节码中。如果地址没有作为参数传递给编译器，那编译的十六进制码将包含如 <code>__Set______</code> 格式的占位符（<code>Set</code> 为类库的名字）。地址可以通过用类库合约地址的十六进制编码替换所有这 40 个符号来手动填充。</p>
<p>与合约比起来，类库的限制：</p>
<ul>
<li>没有状态变量</li>
<li>不能继承或被继承</li>
<li>不能接受以太币</li>
</ul>
<p>（这些可能会在之后被解除）</p>
<h3 id="Call-Protection-For-Libraries"><a href="#Call-Protection-For-Libraries" class="headerlink" title="Call Protection For Libraries"></a>Call Protection For Libraries</h3><p>正如介绍中提到的，如果一个类库的代码通过 <code>CALL</code> 而不是 <code>DELEGATECALL</code> 或者 <code>CALLCODE</code> 来执行，那么除非调用的函数是 <code>view</code> 或者 <code>pure</code>，它都将会被回滚。</p>
<p>EVM 并没有提供一种直接的方式来查看合约是否是通过 <code>CALL</code> 被调用，但是合约可以通过 <code>ADDRESS</code> 操作码来找到当前运行的地址是多少。生成的代码将这个地址与构造时使用的地址进行比较，来决定是使用哪种方式调用。</p>
<p>更具体的说，类库的运行代码总是以一个推送指令开始，该命令在编译时是 20 字节的 0。当部署的代码运行时，这个内存中的常量会被当前的地址替换，并且被修改的代码会被存储在合约中。在运行时，这会导致部署时间地址成为第一个被压入堆栈的常量，并且调度程序代码会将当前地址与此常量进行比较，以查看任何非视图和非纯函数。</p>
<h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h2><p> 指令 <code>using A for B</code> 库添加类库函数（来自类库 <code>A</code>）到任何类型（<code>B</code>）。这些函数会接收它们被调用的对象，并将其作为它们的第一个参数（像 Python 中的 <code>self</code> 变量）。</p>
<p> <code>using A for *</code> 的作用是将类库 <code>A</code> 中的函数都添加到任何类型。</p>
<p> 在这两种情况下，都会附加所有函数，即使是第一个参数的类型与对象类型不匹配的函数。 在函数被调用的地方检查类型并执行函数重载解析。</p>
<p> <code>using A for B</code> 指令只在当前作用域生效，目前是被限制在合约内，但是之后会被解除，放宽到全局，这样通过包含模块，它的数据类型（包括了类库的函数），可以无需添加多余的代码就能直接使用了。</p>
<p> 重写类库 set 示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">	struct Data &#123; mapping(uint =&gt; bool) flags;&#125;</span><br><span class="line"></span><br><span class="line">	function insert(Data storage self, uint value) public reutrns (bool) &#123;</span><br><span class="line">		if (self.flags[value])</span><br><span class="line">			return false;</span><br><span class="line">		self.flags[value] = true;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function remove(Data storage self, uint value) public returns (bool) &#123;</span><br><span class="line">		if (!self.flags[value] = false);</span><br><span class="line">			return false;</span><br><span class="line">		self.flags[value] = false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function contains(Data storage self, uint value) public view returns (bool) &#123;</span><br><span class="line">		return self.flags[value];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	using Set for Set.Data;</span><br><span class="line">	Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">	function register(uint value) public &#123;</span><br><span class="line">		require(knownValues.insert(value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过这种方式来扩展元组类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">	function indexOf(uint[] storage self, uint value) public view returns (uint) &#123;</span><br><span class="line">		for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">			if (self[i] == value) return i;</span><br><span class="line">		return uint(-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">	using Search for uint[];</span><br><span class="line">	uint[] data;</span><br><span class="line"></span><br><span class="line">	funciton append(uint value) public &#123;</span><br><span class="line">		data.push(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function replace(uint _old, uint _new) public &#123;</span><br><span class="line">		uint index = data.indexOf(_old);</span><br><span class="line">		if (index == uint(-1))</span><br><span class="line">			data.push(_new);</span><br><span class="line">		else </span><br><span class="line">			data[index] = _new;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所有的类库调用都是 EVM 的方法调用。意思是如果你传了一个内存或者值类型，就会发生一次复制操作，即使是 <code>self</code> 变量。不使用复制的场景只有在使用存储引用变量时。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/solidity-安全考虑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/27/solidity-安全考虑/" itemprop="url">solidity 安全考虑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-27T14:22:51+08:00">
                2018-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://solidity.readthedocs.io/en/latest/security-considerations.html" target="_blank" rel="noopener">Security Considerations</a></p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><h3 id="Private-Information-and-Randomness-私密信息和随机性"><a href="#Private-Information-and-Randomness-私密信息和随机性" class="headerlink" title="Private Information and Randomness - 私密信息和随机性"></a>Private Information and Randomness - 私密信息和随机性</h3><p>即使本地变量是和状态变量被标记为 <code>private</code>，你在合约中的任何数据都是公开可见的。</p>
<p>如果你不想要矿工有能力作弊，在智能合约中使用随机数是很困难的。</p>
<h3 id="Re-Entrancy-重入"><a href="#Re-Entrancy-重入" class="headerlink" title="Re-Entrancy - 重入"></a>Re-Entrancy - 重入</h3><p>任何合约 A 与合约 B 的交互以及任何转移以太币的操作都将控制权交给了合约 B。那么合约 B 就能在交互完成之前再次调用 A。举例来说，下面的代码包含一个 bug （只是个代码片段，不是完整的合约）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;0.6.0</span><br><span class="line">contract Fund&#123;</span><br><span class="line">    mapping(address=&gt;uint) shares;</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.send(shares[msg.sender]))</span><br><span class="line">        	shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题并不是很严重，因为 <code>send</code> 的 gas 消耗是被限制了的，但是还是存在一个缺陷：以太币的转移是允许代码执行的，所以接收方可以是一个合约，而该合约可以再次调用 <code>withdraw</code>。这可以让合约 B 接收多次转账，基本上能够获得合约 A 中所有的以太币。特别的，下面这个合约使用了 <code>call</code> ，这允许攻击者可以多次退款，因为 <code>call</code> 默认转移剩余所有的 gas：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.0 &lt;0.6.0</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        (bool success,) = msg.sender.call.value(shares[msg.sender])(&quot;&quot;)&apos;;</span><br><span class="line">        if (success) </span><br><span class="line">        	shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免重入，你可以使用 检查交互结果（Checks-Effects-Interactions ）模式，如下所述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.11 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint share = shares[msg.sender];</span><br><span class="line">        shares[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，重入的问题不但存在于以太币的转账操作上，而且还存在于任何调用其他合约方法的操作上。除此之外，还需要考虑多合约的情况。被调用的合约可以修改当前合约依赖的另一个合约的状态。</p>
<h3 id="gas-限制和循环"><a href="#gas-限制和循环" class="headerlink" title="gas 限制和循环"></a>gas 限制和循环</h3><p>循环是没有固定次数的迭代，举例来说，依赖于存储变量的循环需要十分小心：由于区块的 gas 限制，交易只能消耗一定数量的 gas。无论是显式的还是由于常规运算，循环中的迭代次数会增长超过区块的 gas 限制，这会导致完整的合约在某一点停止。当然，这不适用于只读取区块链数据的 view 方法。但是，这些功能可能被其他合约作为链上操作的一部分 and stall those。请在你的合约文档中明确说明此类情况。</p>
<h3 id="发送和接收以太币"><a href="#发送和接收以太币" class="headerlink" title="发送和接收以太币"></a>发送和接收以太币</h3><ul>
<li>目前无论和合约还是外部账户都没有办法拒收以太币。合约可以响应并拒绝常规的转账，但是有一些方法可以不常见消息调用就能转移以太币。一种简单的方法是「挖矿」出来的币直接给合约地址，第二种方法是使用 <code>selfdestruct(x)</code>。</li>
<li>如果一个合约在没有被调用任何方法的情况下接收到以太币，那么合约就会调用 fallback 方法。如果合约没有 fallback 方法，那以太币就会以抛出一个异常的方式被拒收。在 fallback 方法执行期间，合约只能依赖于在该次调用时被指定的 gas 可用数量（2300 gas）。这个数值并不足以用来修改状态变量（这不是绝对的，这个数值可能在未来的硬分叉中被改变）。为了确保可以使用这种方式来接受以太币，需要检测 fallback 方法需要的 gas 数值（比如 Remin 中 details 部分）。</li>
<li>使用 <code>addr.call.value(x)(&quot;&quot;)</code> 可以转移更多的 gas 给接收的合约。这和 <code>addr.transfer(x)</code> 十分相似，只是它会转移所有的剩余 gas 使得接收方可以做花费更高的操作（而且它返回的是失败的代码而不是自动返回错误）。这些操作可能有往回调用合约或者其他你根本没有想到过的状态更改操作。这种方式提供了极大的灵活性，但是并不区分代码是不是恶意的。</li>
<li>如果想要使用 <code>address.transfer</code> 来发送以太币，以下有一些明确的细节需要注意：<ul>
<li>如果接收者是一个合约，它可以使得它的 fallback 方法又再次调用发起合约。</li>
<li>如果调用深度超过了 1024，那么以太币的发送可能失败。因为调用者可以完全控制调用的深度，所以它可以强制转移以太币失败。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/token-合约大数溢出安全问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/token-合约大数溢出安全问题/" itemprop="url">token 合约大数溢出安全问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T15:21:03+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周连续爆出一些比较知名的 token 的安全问题，后续有消息称仍然存在同类问题的 token。简单描述一下该类问题的存在形式。</p>
<h2 id="BEC"><a href="#BEC" class="headerlink" title="BEC"></a>BEC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123;</span><br><span class="line">  uint cnt = _receivers.length;</span><br><span class="line">  uint256 amount = uint256(cnt) * _value; // 大数溢出 amount 可能从 11111.....1111 体现成 1111 从而在发送者的余额范围内</span><br><span class="line">  require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</span><br><span class="line">  require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">  balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">  for (uint i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">      balances[_receivers[i]] = balances[_receivers[i]].add(_value); // 各个地址增加 _value 余额</span><br><span class="line">      Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BEC</code> 的问题出现在 <code>batchTransfer</code> 方法。如注释所述，当 <code>amount</code> 超过最大值，那么该值会被截取范围内的数字，当截取后的数字处在当前用户余额范围内，那么 <code>_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount</code> 成立。后面的代码就可以正常执行，余额减去实际的 <code>amount</code> 截取后的较小数字，然后可以给地址列表内的地址增加 <code>_value</code> 余额。</p>
<h2 id="SMT"><a href="#SMT" class="headerlink" title="SMT"></a>SMT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt,</span><br><span class="line">    uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123;</span><br><span class="line"></span><br><span class="line">    // 将 _feeSmt + _value 的和截取后溢出值小于发起者余额 绕过检测</span><br><span class="line">    // _value = 8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">    // _feeSmt = 7000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">    if(balances[_from] &lt; _feeSmt + _value) revert();</span><br><span class="line"></span><br><span class="line">    uint256 nonce = nonces[_from]; // 获得发起人 nonce </span><br><span class="line">    bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce);</span><br><span class="line">    if(_from != ecrecover(h,_v,_r,_s)) revert();</span><br><span class="line"></span><br><span class="line">    // _value &gt; 0 , _feeSmt &gt; 0</span><br><span class="line">    if(balances[_to] + _value &lt; balances[_to]</span><br><span class="line">        || balances[msg.sender] + _feeSmt &lt; balances[msg.sender]) revert();</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    Transfer(_from, _to, _value);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] += _feeSmt;</span><br><span class="line">    Transfer(_from, msg.sender, _feeSmt);</span><br><span class="line"></span><br><span class="line">    balances[_from] -= _value + _feeSmt; // 发起人扣币为溢出之后截取的值</span><br><span class="line">    nonces[_from] = nonce + 1; </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SMT</code> 的问题在 <code>transferProxy</code> 方法。如注释所述（注释中的数值示例是从异常交易中查看得到的，这里是将两个数字之和刚好溢出而得到 0 的情况），当 <code>_feeSmt + _value</code> 的和溢出之后，截取的较小数字处在余额范围内，就可以通过 <code>balances[_from] &lt; _feeSmt + _value</code> 的判断条件。后续代码继续执行，就会给 <code>_to</code> 用户的余额中增加资产。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果无法保证自身在编码时考虑到一切细节，那么应该使用安全的数学类库来进行相关的操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/智能合约最佳实践翻译六-文档和程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/智能合约最佳实践翻译六-文档和程序/" itemprop="url">智能合约最佳实践翻译六 - 文档和程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T18:05:44+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文档和程序"><a href="#文档和程序" class="headerlink" title="文档和程序"></a><a href="https://consensys.github.io/smart-contract-best-practices/documentation_procedures/" target="_blank" rel="noopener">文档和程序</a></h2><p>在启动一个将会拥有大量资金或者被要求作为关键任务的合约，拥有标准的文档是十分重要的。一些与安全相关的文档包括：</p>
<h3 id="详细说明和推出计划"><a href="#详细说明和推出计划" class="headerlink" title="详细说明和推出计划"></a>详细说明和推出计划</h3><ul>
<li>规范，图表，状态机，模型和其他可以帮助审计人员，审阅人员和社区理解系统打算做什么的文档。</li>
<li>许多错误可以从详细说明中找到，而这种错误的修复成本是最低的。</li>
<li>推出的计划包含<a href="https://github.com/ConsenSys/smart-contract-best-practices#contract-rollout" target="_blank" rel="noopener">此处</a>列出的细节，和目标日期。</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>当前代码部署的地方</li>
<li>编译器版本，使用的标志，和源代码部署之后的字节码的验证步骤</li>
<li>不同的推出阶段所使用的编译器版本和标志</li>
<li>部署的代码的当前状态（包括未解决的问题，和性能状态等等）</li>
</ul>
<h3 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h3><ul>
<li>合约中的主要风险</li>
<li>如，你可能失去所有的钱，黑客可以为指定结果投票</li>
<li>所有已知的错误和限制</li>
<li>潜在的攻击和缓解方法</li>
<li>潜在的利益冲突（如，被你自己使用，就像 Slock.it 对 DAO 做的那样）</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li>测试（包含使用状态，发现的错误，测试长度）</li>
<li>审阅了代码的人（和他们主要的反馈）</li>
</ul>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li>发现错误时的行动计划（如，紧急选项，公开通知进程等）</li>
<li>如果出现问题，请降低风险流程（例如，出资者在会从余下的资金中获得攻击之前余额的百分比）</li>
<li>负责任的披露政策（例如，发现错误之后的报告的地方，任何错误奖励计划的规则）</li>
<li>失败求助（如，保险，罚款，没有帮助）</li>
</ul>
<h3 id="合约信息"><a href="#合约信息" class="headerlink" title="合约信息"></a>合约信息</h3><ul>
<li>有问题时可以联系的人</li>
<li>开发者的名字或者其他重要的第三方</li>
<li>可以提问的聊天室</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/智能合约最佳实践翻译八-安全通知/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/智能合约最佳实践翻译八-安全通知/" itemprop="url">智能合约最佳实践翻译八 - 安全通知</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T18:01:16+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安全通知"><a href="#安全通知" class="headerlink" title="安全通知"></a><a href="https://consensys.github.io/smart-contract-best-practices/security_notifications/" target="_blank" rel="noopener">安全通知</a></h2><p>这是一个资源清单，通常会强调在以太坊或 Solidity 中发现的漏洞。安全通知的官方来源是以太坊博客，但在很多情况下，漏洞会更早地在其他地方披露和讨论。</p>
<ul>
<li><a href="https://blog.ethereum.org/" target="_blank" rel="noopener">Ethereum Blog</a> : 以太坊官方博客</li>
<li><a href="https://blog.ethereum.org/category/security/" target="_blank" rel="noopener">Ethereum Blog - Security only</a> : 安全类的博客文章</li>
<li><a href="https://gitter.im/orgs/ethereum/rooms" target="_blank" rel="noopener">Ethereum Gitter</a> : 聊天室</li>
<li><a href="https://gitter.im/ethereum/solidity" target="_blank" rel="noopener">Solidity</a></li>
<li><a href="https://gitter.im/ethereum/go-ethereum" target="_blank" rel="noopener">Go-Ethereum</a></li>
<li><a href="https://gitter.im/ethereum/cpp-ethereum" target="_blank" rel="noopener">CPP-Ethereum</a></li>
<li><a href="https://gitter.im/ethereum/research" target="_blank" rel="noopener">Research</a></li>
<li><a href="https://www.reddit.com/r/ethereum" target="_blank" rel="noopener">Reddit</a></li>
<li><a href="https://ethstats.net/" target="_blank" rel="noopener">Network Stats</a></li>
</ul>
<p>强烈建议你定期阅读以上所有来源，因为他们注意到的漏洞可能会影响你的合约。</p>
<p>另外，这里列出了一些可能会写关于安全性的内容的以太坊核心开发人员，你也可以从社区中看到更多的<a href="https://github.com/ConsenSys/smart-contract-best-practices#smart-contract-security-bibliography" target="_blank" rel="noopener">参考书目</a>。</p>
<ul>
<li><strong>Vitalik Buterin:</strong> <a href="https://twitter.com/vitalikbuterin" target="_blank" rel="noopener">Twitter</a>, <a href="https://github.com/vbuterin" target="_blank" rel="noopener">Github</a>, <a href="https://www.reddit.com/user/vbuterin" target="_blank" rel="noopener">Reddit</a>, <a href="https://blog.ethereum.org/author/vitalik-buterin/" target="_blank" rel="noopener">Ethereum Blog</a></li>
<li><strong>Dr. Christian Reitwiessner:</strong> <a href="https://twitter.com/ethchris" target="_blank" rel="noopener">Twitter</a>, <a href="https://github.com/chriseth" target="_blank" rel="noopener">Github</a>, <a href="https://blog.ethereum.org/author/christian_r/" target="_blank" rel="noopener">Ethereum Blog</a></li>
<li><strong>Dr. Gavin Wood:</strong> <a href="https://twitter.com/gavofyork" target="_blank" rel="noopener">Twitter</a>, <a href="http://gavwood.com/" target="_blank" rel="noopener">Blog</a>, <a href="https://github.com/gavofyork" target="_blank" rel="noopener">Github</a></li>
<li><strong>Vlad Zamfir:</strong>  <a href="https://twitter.com/vladzamfir" target="_blank" rel="noopener">Twitter</a>, <a href="https://github.com/vladzamfir" target="_blank" rel="noopener">Github</a>,<a href="https://blog.ethereum.org/author/vlad/" target="_blank" rel="noopener">Ethereum Blog</a></li>
</ul>
<p>除了关注核心开发人员之外，参与更广泛的区块链相关安全社区也很重要 - 因为安全披露或观察会有很多不同的来源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/智能合约最佳实践翻译七-安全工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/智能合约最佳实践翻译七-安全工具/" itemprop="url">智能合约最佳实践翻译七 - 安全工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T18:01:16+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a><a href="https://consensys.github.io/smart-contract-best-practices/security_tools/" target="_blank" rel="noopener">安全工具</a></h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><ul>
<li><a href="https://github.com/trailofbits/manticore" target="_blank" rel="noopener">Manticore</a> - 支持 EVM 的动态二进制分析工具</li>
<li><a href="https://github.com/b-mueller/mythril/" target="_blank" rel="noopener">Mythril</a> - 以太坊区块链的逆向和 bug 搜索框架</li>
<li><a href="https://github.com/melonproject/oyente" target="_blank" rel="noopener">Oyente</a> - 基于 <a href="http://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf" target="_blank" rel="noopener">此论文</a>，分析以太坊代码来寻找普遍的漏洞</li>
<li><a href="https://github.com/raineorshine/solgraph" target="_blank" rel="noopener">Solgraph</a> - 生成一个 DOT 图表，可视化 Solidity 合约的功能控制流程并高亮显示潜在的安全漏洞。</li>
<li><a href="https://tool.smartdec.net/" target="_blank" rel="noopener">SmartCheck</a> - 针对安全漏洞和最佳实践的 Solidity 源代码的静态分析。</li>
</ul>
<h3 id="测试范围"><a href="#测试范围" class="headerlink" title="测试范围"></a>测试范围</h3><ul>
<li><a href="https://github.com/sc-forks/solidity-coverage" target="_blank" rel="noopener">solidity-coverage</a> - Solidity 测试的代码范围</li>
</ul>
<h3 id="Linters"><a href="#Linters" class="headerlink" title="Linters"></a>Linters</h3><p>Linters 通过强制样式和组合的规则来提高代码质量，使代码更易于阅读和查看。</p>
<ul>
<li><a href="https://github.com/federicobond/solcheck" target="_blank" rel="noopener">Solcheck</a> - 一个用 JS 编写的 Solidity 代码的 linter，深受 eslint 的启发</li>
<li><a href="https://github.com/weifund/solint" target="_blank" rel="noopener">Solint</a> - Solidity linting 可帮助您执行一致的约定并避免 Solidity 智能合约中的错误。</li>
<li><a href="https://github.com/duaraghav8/Solium" target="_blank" rel="noopener">Solium</a> - 另一种Solidity linting</li>
<li><a href="https://github.com/protofire/solhint" target="_blank" rel="noopener">Solhint</a> - 为 Solidity 提供安全和样式指南验证的 linter 。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/智能合约最佳实践翻译五-Token-实现最佳实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/智能合约最佳实践翻译五-Token-实现最佳实践/" itemprop="url">智能合约最佳实践翻译五 - Token 实现最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T11:37:52+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Token-实现最佳实践"><a href="#Token-实现最佳实践" class="headerlink" title="Token 实现最佳实践"></a>Token 实现最佳实践</h2><p>实现 Token 应该符合其他的最佳实践，但是它有一些独特的考虑。</p>
<h3 id="遵守最新的标准"><a href="#遵守最新的标准" class="headerlink" title="遵守最新的标准"></a>遵守最新的标准</h3><p>通常来说，token 的智能合约应该遵循公认的稳定标准。</p>
<p>当前公认的标准有：</p>
<ul>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">EIP20</a></li>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener">EIP721</a>（不可替代的 token）</li>
</ul>
<h3 id="注意-EIP-20-的前期攻击"><a href="#注意-EIP-20-的前期攻击" class="headerlink" title="注意 EIP-20 的前期攻击"></a>注意 EIP-20 的前期攻击</h3><p>EIP-20 的 token 的 <code>approve()</code> 函数可能会让第三方提币量超过设置的预定数量。一个 <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running" target="_blank" rel="noopener">前期攻击</a> 可以使得一个经过授权的用户不论是在调用方法 <code>approve()</code> 之前还是之后都可以调用 <code>transferFrom()</code> 函数。更多细节可见 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve" target="_blank" rel="noopener">EIP</a> 和 <a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" target="_blank" rel="noopener">此文档</a>。</p>
<h3 id="防止将-token-转到地址-0x0"><a href="#防止将-token-转到地址-0x0" class="headerlink" title="防止将 token 转到地址 0x0"></a>防止将 token 转到地址 0x0</h3><p>在写本文的此刻，“零”地址（<a href="https://etherscan.io/address/0x0000000000000000000000000000000000000000" target="_blank" rel="noopener">0x0000000000000000000000000000000000000000</a>）所拥有的 token 的价值超过了 8000,000 美元。</p>
<h3 id="防止将-token-转到合约地址"><a href="#防止将-token-转到合约地址" class="headerlink" title="防止将 token 转到合约地址"></a>防止将 token 转到合约地址</h3><p>注意不要将 token 转到和智能合约地址相同的地址。</p>
<p>该情况下损失的一个例子就是 EOS token 的智能合约地址中有超过 90000 个 token。</p>
<p><strong>例子：</strong></p>
<p>实现上面的这些推荐的一个例子会创建下面这个修饰器，验证 <code>to</code> 地址不会是 0x0 也不会是该 token 自己的合约地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modifier validDestination(address to) &#123;</span><br><span class="line">	require(to != address(0x0));</span><br><span class="line">	require(to != address(this));</span><br><span class="line">	_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该修饰器被添加到 <code>transfer</code> 和 <code>transferFrom</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class="line">	//some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) &#123;</span><br><span class="line">	//some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/智能合约最佳实践翻译四-软件工程技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/智能合约最佳实践翻译四-软件工程技术/" itemprop="url">智能合约最佳实践翻译四 - 软件工程技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T11:37:45+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="软件工程技术"><a href="#软件工程技术" class="headerlink" title="软件工程技术"></a>软件工程技术</h2><p>如我们在<a href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy" target="_blank" rel="noopener">常规理念</a>中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。</p>
<p>我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。</p>
<p>注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。</p>
<h3 id="改进被破坏的合约"><a href="#改进被破坏的合约" class="headerlink" title="改进被破坏的合约"></a>改进被破坏的合约</h3><p>当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。</p>
<p>为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。</p>
<p>不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。</p>
<p>提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如<a href="https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality" target="_blank" rel="noopener">紧急停止或者是熔断机制</a>。</p>
<p><strong>示例 1:使用一个注册合约来存储另一个合约的最新版本</strong></p>
<p>在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract SomeRegister &#123;</span><br><span class="line">	address backendContract;</span><br><span class="line">	address[] previousBackends;</span><br><span class="line">	address owner;</span><br><span class="line"></span><br><span class="line">	function SomeRegister() &#123;</span><br><span class="line">		owner = msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	modifier onlyOwner() &#123;</span><br><span class="line">		require(msg.sender == owner)</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function changeBackend(address newBackend) public onlyOwner() returns (bool) &#123;</span><br><span class="line">		if (newBackend != backendContract) &#123;</span><br><span class="line">			previousBackend.push(backendContract);</span><br><span class="line">			backendContract = newBackend;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个缺点：</p>
<ol>
<li>用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。</li>
<li>你需要在替换合约的时候小心的思考如果处理合约内的数据。</li>
</ol>
<p>另一种方法是让合约将调用和数据转发给合约的最新版本：</p>
<p><strong>示例 2：<a href="http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts" target="_blank" rel="noopener">使用 <code>DELEGATECALL</code></a> 来转发数据和调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract Relay　&#123;</span><br><span class="line">	address public currentVersion;</span><br><span class="line">	address public owner;</span><br><span class="line"></span><br><span class="line">	modifier onlyOwner() &#123;</span><br><span class="line">		require(msg.sender == owner);</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function Relay(address initAddr) &#123;</span><br><span class="line">		currentVersion = initAddr;</span><br><span class="line">		owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function changeContract(address newVersion) public onlyOwner() &#123;</span><br><span class="line">		currentVersion = newVersion;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function() &#123;</span><br><span class="line">		require(currentVersion.delegatecall(msg.data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方式避免了之前的问题，但他本身又存在问题。在这个合约中存储数据的时候你必须极度小心。如果你的新合约和第一个的存储结构不同，你的数据可能会被破坏。另外，这种模式的简单版本不会从函数返回值，只会转发他们，这限制了它的适用性。（<a href="https://github.com/ownage-ltd/ether-router" target="_blank" rel="noopener">更复杂的实现方式</a>则是试图通过内联汇编代码和返回大小的注册表来解决这个问题。）</p>
<p>不管你的方法是什么，重要的是要有某种方法来升级你的合约，否则当不可避免的错误被发现时，它们将变得无法使用。</p>
<h3 id="断路器（暂停合约功能）"><a href="#断路器（暂停合约功能）" class="headerlink" title="断路器（暂停合约功能）"></a>断路器（暂停合约功能）</h3><p>当触发了确定的条件，断路器会停止当前的执行，而对于新发现的错误，它也十分有用。举例来说，如果发现了错误，合约中除了提币操作，其他大多数操作可能都会暂停。你既可以给某些可信的一方触发断路器的能力，也可以设定在某些条件满足时自动触发某些断路器的程序规则。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool private stopped = false;</span><br><span class="line">address private owner;</span><br><span class="line"></span><br><span class="line">modifier isAdmin() &#123;</span><br><span class="line">	require(msg.sender == owner);</span><br><span class="line">	_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toggleContractActive() isAdmin public &#123;</span><br><span class="line">	// You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users</span><br><span class="line">	stopped = !stopped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modifier stopInEmergency &#123;if (!stopped) _;&#125;</span><br><span class="line">modifier onlyInEmergency &#123;if（stopped）_;&#125;</span><br><span class="line"></span><br><span class="line">function deposit() stopInEmergency public &#123;</span><br><span class="line">	// some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdraw() onlyInEmergency public &#123;</span><br><span class="line">	// some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="速度碰撞（延迟合约动作）"><a href="#速度碰撞（延迟合约动作）" class="headerlink" title="速度碰撞（延迟合约动作）"></a>速度碰撞（延迟合约动作）</h3><p>速度碰撞使得动作变慢，所以如果发生了恶意的动作，就有时间来恢复了。举例来说，<a href="https://github.com/slockit/DAO/" target="_blank" rel="noopener">The DAO</a>在一个拆分 DAO 的成功请求和完成该请求之间需要 27 天的时间。这保证了资金被保存在合约内，增加了恢复的可能性。在 DAO 这个例子中，在速度碰撞期间内无法采取有效的行动，但是与其他技术相结合，这就相当有效了。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct RequestedWithdrawal &#123;</span><br><span class="line">	uint amount;</span><br><span class="line">	uint time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; uint) private balances;</span><br><span class="line">mapping(address =&gt; RequestedWithdrawal) private requestedWithdrawals</span><br><span class="line">uint constant withdrawalWaitPeriod = 28 days; // 4 weeks</span><br><span class="line"></span><br><span class="line">function requestWithdrawal() public &#123;</span><br><span class="line">	 if (balances[msg.sender] &gt; 0) &#123;</span><br><span class="line">	 	uint amountToWithdraw = balances[msg.sender];</span><br><span class="line">	 	balances[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">	 	requestedWithdrawals[msg.sender] = RequestedWithdrawal(&#123;</span><br><span class="line">	 		amount: amountToWithdraw,</span><br><span class="line">	 		time: now</span><br><span class="line">	 		&#125;);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdraw() public &#123;</span><br><span class="line">	if(requestedWithdrawals[msg.sender].amount &gt; 0 &amp;&amp; now &gt; requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) &#123;</span><br><span class="line">		uint amountToWithdraw = requestedWithdrawals[msg.sender].amount;</span><br><span class="line">		requestedWithdrawals[msg.sender].amount = 0;</span><br><span class="line"></span><br><span class="line">		require(msg.sender.send(amountToWithdraw));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比例限制"><a href="#比例限制" class="headerlink" title="比例限制"></a>比例限制</h3><p>比例限制停止或要求实质性变更的通过。举例来说，一个存款人在一定时期内只允许提取一定数量或一定百分比的存款（如 一天最多 100 ether）- 另外在该时期内的提币将会失败或者需要一些特殊的审批通过。或者比例限制可以通过在该时期内合约只能提取一定的 token 的形式在合约层面实现。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">contract CircuitBreaker &#123;</span><br><span class="line">	struct Transfer &#123;</span><br><span class="line">		uint amount;</span><br><span class="line">		address to;</span><br><span class="line">		uint releaseBlock;</span><br><span class="line">		bool released;</span><br><span class="line">		bool stopped;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Transfer[] public transfers;</span><br><span class="line"></span><br><span class="line">	address public curator;</span><br><span class="line">	address public authorizedSender;</span><br><span class="line">	uint public period;</span><br><span class="line">	uint public limit;</span><br><span class="line"></span><br><span class="line">	uint public currentPeriodEnd;</span><br><span class="line">	uint public currentPeriodAmount;</span><br><span class="line"></span><br><span class="line">	event PendingTransfer(uint id, uint amount, address to, uint releaseBlock);</span><br><span class="line"></span><br><span class="line">	function CircuitBreaker(address _curator, address _authorizedSender, uint _period, uint _limit) &#123;</span><br><span class="line">		curator = _curator;</span><br><span class="line">		period = _period;</span><br><span class="line">		limit = _limit;</span><br><span class="line">		authorizedSender = _authorizedSender;</span><br><span class="line">		currentPeriodEnd = block.number + period;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function transfer(uint amount, address to) &#123;</span><br><span class="line">		if (msg.sender == authorizedSender) &#123;</span><br><span class="line">			updatePeriod();</span><br><span class="line"></span><br><span class="line">			if (currentPeriodAmount + amount &gt; limit) &#123;</span><br><span class="line">				uint releaseBlock = block.number + period;</span><br><span class="line">				PendingTransfer(transfer.length, amount, to, releaseBlock);</span><br><span class="line">				transfer.push(Transfer(amount, to, releaseBlock, false, false));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				currentPeriodAmount += amount;</span><br><span class="line">				transfers.push(Transfer(amount, to, block.number, true, false));</span><br><span class="line">				if (!to.sender(amount)) throw;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function updatePeriod() &#123;</span><br><span class="line">		if (currentPeriodEnd &lt; block.number) &#123;</span><br><span class="line">			currentPeriodEnd = block.number + period;</span><br><span class="line">			currentPeriodAmount = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function releasePendingTransfer(uint id) &#123;</span><br><span class="line">		Transfer transfer = transfers[id];</span><br><span class="line">		if (transfer.releaseBlock &lt;= block.number &amp;&amp; !transfer.released &amp;&amp; !transfer.stopped) &#123;</span><br><span class="line">			transfer.released = true;</span><br><span class="line">			if (!transfer.to.send(transfer.amount)) throw;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function stopTransfer(uint id) &#123;</span><br><span class="line">		if (msg.sender == curator) &#123;</span><br><span class="line">			transfer[id].stopped = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h3><p>在资金处于危险之前，合约应该有大量的长期的测试阶段。</p>
<p>最小程度，你应该：</p>
<ul>
<li>有一个完整的测试套件，覆盖了 100%（或者接近） 的测试。</li>
<li>部署在你自己的测试网络上。</li>
<li>经过大量的测试之后才能发布在公共测试网络上，并且要发布 bug 悬赏。</li>
<li>详尽的测试应该包括大量不同的玩家同时与合约交互。</li>
<li>将 beta 版本部署在主网上，降低风险。</li>
</ul>
<h5 id="自动防护"><a href="#自动防护" class="headerlink" title="自动防护"></a>自动防护</h5><p>在测试期，你可以设置在一定时期之后自动反对来防止任何的操作。举例来说，一个 alpha 版本的合约在工作几周之后会自动关闭所有的操作，除了最终的提币。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">modifier isActive() &#123;</span><br><span class="line">	requrie(block.number &lt;= SOME_BLOCK_NUMBER);</span><br><span class="line">	_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function deposit() public isActive &#123;</span><br><span class="line">	// some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdraw() public &#123;</span><br><span class="line">	// some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="限制每个用户-合约的-ETH-数量"><a href="#限制每个用户-合约的-ETH-数量" class="headerlink" title="限制每个用户/合约的 ETH 数量"></a>限制每个用户/合约的 ETH 数量</h5><p>在早期阶段，你可以限制任何用户（或者整个合约）的 ETH 数量来降低风险。</p>
<h3 id="bug-悬赏计划"><a href="#bug-悬赏计划" class="headerlink" title="bug 悬赏计划"></a>bug 悬赏计划</h3><p>一些悬赏计划的技巧：</p>
<ul>
<li>决定奖励哪些货币（BTC 或者 ETH）</li>
<li>决定悬赏的总预算</li>
<li>从预算中确定三层奖励：</li>
<li>你愿意付出的最小奖励</li>
<li>最高的奖励是可以常常被获得的</li>
<li>如果存在非常严重的漏洞，将额外给予的奖励范围</li>
<li>确定赏金评委是谁（3人可能是典型的理想人选）</li>
<li>首席开发者可能应该是赏金评委之一</li>
<li>当收到错误报告时，首席开发人员应该根据评委的建议评估错误的严重程度</li>
<li>在这个阶段的工作应该是在一个私有仓库，并归档在 Github 上提出的问题</li>
<li>如果这是一个应该修复的 bug，那么在私有仓库中，开发人员应该编写一个测试用例，这个用例应该会失败，从而确认 bug</li>
<li>开发人员应该执行修复程序并确保测试通过; 根据需要编写额外的测试</li>
<li>给赏金猎人展示修复工作; 将修复合并入公共仓库是一种方法</li>
<li>确定赏金猎人是否有任何其他有关修复的反馈</li>
<li>赏金评委根据他们对 bug 的 <em>可能性</em> 和 <em>影响</em> 的评估来确定奖励的大小</li>
<li>在整个过程中保持奖励参与者的信息，然后努力避免延误向他们发送奖励</li>
</ul>
<p>有关三种奖励的例子，请参阅<a href="https://bounty.ethereum.org/" target="_blank" rel="noopener">以太坊的赏金计划</a>：</p>
<blockquote>
<p>支付的奖励价值取决于影响的严重程度。 对轻微“无害”错误的奖励最少 0.05 BTC。例如，导致共识问题的错误将奖励高达 5 BTC。 如果存在非常严重的漏洞，可能获得更高的奖励（高达 25 BTC）。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/本地运行-geth-记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fuyk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/本地运行-geth-记录/" itemprop="url">本地运行 geth 记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T16:04:12+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>添加源，安装客户端：</p>
<p><code>apt install software-properties-common</code></p>
<p><code>add-apt-repository -y ppa:ethereum/ethereum</code></p>
<p><code>apt install ethereum</code></p>
<p>添加源，安装 solc：</p>
<p><code>add-apt-repository ppa:ethereum/ethereum</code></p>
<p><code>apt update</code></p>
<p><code>apt install solc</code></p>
<h3 id="创世文件"><a href="#创世文件" class="headerlink" title="创世文件"></a>创世文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;config&quot;: &#123;</span><br><span class="line">	    &quot;chainId&quot;: 0,</span><br><span class="line">	    &quot;homesteadBlock&quot;: 0,</span><br><span class="line">	    &quot;eip155Block&quot;: 0,</span><br><span class="line">	    &quot;eip158Block&quot;: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;alloc&quot;      : &#123;&#125;,</span><br><span class="line">	&quot;coinbase&quot;   : &quot;0x0000000000000000000000000000000000000000&quot;,</span><br><span class="line">	&quot;difficulty&quot; : &quot;0x20000&quot;,</span><br><span class="line">	&quot;extraData&quot;  : &quot;&quot;,</span><br><span class="line">	&quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,</span><br><span class="line">	&quot;nonce&quot;      : &quot;0x0000000000000042&quot;,</span><br><span class="line">	&quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">	&quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">	&quot;timestamp&quot;  : &quot;0x00&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>config</code>中：<br><code>chainId</code> ：<br>​    1. 指定独立的区块链网络 ID。网络 ID 在连接到其他节点的时候会用到，以太坊公网的网络 ID 是 1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络 ID。不同 ID 网络的节点无法相互连接。<a href="https://g2ex.github.io/2017/09/12/ethereum-guidance/" target="_blank" rel="noopener">以太坊私有链搭建指南</a><br>​    2. 标识当前链以及防护重放攻击<a href="https://ethereum.stackexchange.com/questions/15682/the-meaning-specification-of-config-in-genesis-json/15687#15687" target="_blank" rel="noopener">The meaning/specification of “config” in genesis.json</a><br><code>homesteadBlock</code> ：个人私链不会连接进主链，所以设为 0 - your chain won’t be undergoing the switch to Homestead, so leave this as 0. <a href="https://ethereum.stackexchange.com/questions/15682/the-meaning-specification-of-config-in-genesis-json/15687#15687" target="_blank" rel="noopener">The meaning/specification of “config” in genesis.json</a><br><code>eip155Block</code> ：<br><code>eip158Block</code> ： 个人私链不会使用这些改变硬分叉，所以设为 0. - your chain won’t be hard-forking for these changes, so leave as 0.<a href="https://ethereum.stackexchange.com/questions/15682/the-meaning-specification-of-config-in-genesis-json/15687#15687" target="_blank" rel="noopener">The meaning/specification of “config” in genesis.json</a></p>
<p><a href="https://bitshuo.com/topic/5a2bec4a37e357a67e3a34ab" target="_blank" rel="noopener">相关协议机制的升级区块所在的高度，签名算法是homestead -&gt;eip155 -&gt; eip158，所以从homesteadBlock之前区块都通过homestead相关算法机制来验证，homesteadBlock 到 eip155Block之间的用eip155算法来验证，依次类推</a></p>
<p>可根据个人需要自由配置。主链会忽略这部分设置。</p>
</li>
<li><p><a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">go-ethereum</a>: 上述配置适合于大多数情况，推荐将 <code>nonce</code> 更改为一些随机数，这样可以防止被一些其他可以连接的未知节点连上。可以预置一些账户资金来方便测试，在 <code>alloc</code> 字段中增加账户的配置 ：<br>​<br>“alloc”: {<br>​    “0x0000000000000000000000000000000000000001”: {“balance”: “111111111”},<br>​    “0x0000000000000000000000000000000000000002”: {“balance”: “222222222”}<br>​    }</p>
</li>
<li><p><code>mixhash</code> : 与 <code>nonce</code> 配合用于挖矿，由上一个区块的一部分生成的 <code>hash</code>。此值的设置需要满足以太坊的 <code>Yellow paper, 4.3.4. Block Header Validity, (44)</code> 章节所描述的条件。</p>
</li>
<li><p><code>nonce</code> : 一个 64 位随机数，用于挖矿，此值的设置需要满足以太坊的 <code>Yellow paper, 4.3.4. Block Header Validity, (44)</code>章节所描述的条件。</p>
</li>
<li><p><code>difficulty</code> : 设置当前区块的难度。</p>
</li>
<li><p><code>coinbase</code> : 矿工账号</p>
</li>
<li><p><code>extraData</code> : 附加的信息</p>
</li>
<li><p><code>gasLimit</code> : 该值设置对 <code>GAS</code> 的消耗总量限制，用来限制区块能包含的交易信息总和</p>
</li>
<li><p><code>parentHash</code> : 上一个区块的 <code>hash</code> 值，因为是创世块，所以这个值是 0</p>
</li>
<li><p><code>timestamp</code> : 设置创世块的时间戳</p>
</li>
</ul>
<h3 id="写入创世区块。-修改了配置文件需要重新初始化创世块。"><a href="#写入创世区块。-修改了配置文件需要重新初始化创世块。" class="headerlink" title="写入创世区块。-修改了配置文件需要重新初始化创世块。"></a>写入创世区块。-修改了配置文件需要重新初始化创世块。</h3><p>在创世配置文件同级目录中创建一个新目录用来存放区块链数据。</p>
<p>在创世配置文件同级目录中，执行初始化命令。 <code>geth --datadir data_dir init genesis.json</code>。</p>
<p>(报错：<code>Fatal: invalid genesis file: json: cannot unmarshal hex string of odd length into Go struct field Genesis.extraData of type hexutil.Bytes</code>，原因是从v1.6开始，设置的十六进制数值，不能是奇数位， 比如不能是 <code>0x0</code>，而应该是 <code>0x00</code>。)</p>
<p>成功后数据目录 <code>data_dir</code> 内会有两个目录： <code>geth/chaindata</code> 存放区块数据，<code>keystore</code> 存放账户数据。</p>
<h3 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h3><p><code>geth --identity &quot;TestNode&quot; --rpc --rpcport &quot;8545&quot; --datadir data0 --port &quot;30303&quot; --nodiscover console</code></p>
<p>主体命令为 <code>geth console</code>。<code>geth</code> 相关配置选项如下：</p>
<p>使用方法： <code>geth [选项] 命令 [命令选项] [参数]</code></p>
<ul>
<li>命令：<br><code>account</code>        管理账户<br><code>attach</code>          开启一个 <code>JavaScript</code> 的交互环境（连接节点）<br><code>bug</code>              在 <code>geth</code> 包上打开一个窗口来报告一个 <code>bug</code><br><code>console</code>         开启一个 <code>JavaScript</code> 的交互环境<br><code>copydb</code>          从指定的链数据目录创建一个本地链<br><code>dump</code>              另外存储指定的块<br><code>dumpconfig</code>     展示配置值<br><code>export</code>        导出区块链到文件<br><code>import</code>        导入一个区块链文件<br><code>init</code>             引导并初始化一个新的创世区块<br><code>js</code>            执行指定的 <code>JavaScript</code> 文件<br><code>license</code>         展示证书信息<br><code>makecache</code>     生成 <code>ethash</code> 验证缓存（用于测试）<br><code>makedag</code>        生成 <code>ethash</code> 挖矿 <code>DAG</code> (用于测试)<br><code>monitor</code>         监视和可视化节点度量<br><code>removedb</code>        删除区块链和状态数据库<br><code>version</code>        打印版本号<br><code>wallet</code>        管理以太坊预售钱包<br><code>help, h</code>         展示命令列表或者指定命令的帮助信息</li>
<li><code>ethereum</code> 选项：<br><code>--config value</code>                    <code>TOML</code> 配置文件<br><code>--datadir &quot;/path/to/.ethereum&quot;</code>    数据库和账户的数据存储目录<br><code>--keystore</code>                        账户数据存储目录 （<code>default</code> - 默认在 <code>datadir</code> 中）<br><code>--nousb</code>                            禁用监视和管理USB硬件钱包<br><code>--networkid value</code>                    网络标识符（整型，<code>1=Frontier, 2=Morden (disused), 3=Ropsten, 4=Rinkeby</code>) (默认 1)<br><code>--testnet</code>                            <code>Ropsten</code> 网络：预先配置的工作量证明机制的测试网络<br><code>--rinkeby</code>                            <code>Rinkeby</code> 网络：预先配置的权威证明机制的测试网络<br><code>--syncmode &quot;fast&quot;</code>                    区块链同步模式（”fast”,”full”,”light”）<br><code>--ethstats value</code>                    报告 <code>ethstats</code> 服务的 <code>url</code> （节点名称：<code>secret@host:port</code>）<br><code>--identity value</code>                    设置节点名称<br><code>--lightserv value</code>                    允许服务 <code>LES</code> 请求的最大时间百分比（0-90）（默认值：0）<br><code>--lightpeers value</code>                <code>LES</code> 客户端节点的最大值（默认 20）<br><code>--lightkdf</code>                         减少密钥派生内存和CPU使用率的一些 <code>KDF</code> 强度的耗费</li>
<li>开发者的链选项：<br><code>--dev</code>                    采用预先资助的开发人员帐户的临时权威证明网络，挖矿功能开启。<br><code>--dev.period value</code>     在开发人员模式下使用的块周期（0 =仅在事务处于待处理状态时使用）（默认值：0)</li>
<li><code>ethash</code> 选项：<br><code>--ethash.cachedir</code>                        保存 <code>ethash</code> 验证缓存的目录（默认在 <code>datadir</code> 中）<br><code>--ethash.cachesinmem value</code>            保留在内存中的最新ethash缓存数量（每个16MB）（默认值：2）<br><code>--ethash.cachesondisk value</code>            保留在磁盘上的最新ethash缓存数量（每个16MB）（默认值：3）<br><code>--ethash.dagdir &quot;/path/to/.ethash&quot;</code>    存储 <code>ethash</code> 挖矿的 <code>DAG</code> 的目录（默认在用户目录内）<br><code>--ethash.dagsinmem value</code>                内存中最近使用的 <code>ethash</code> 挖矿 <code>DAG</code> 的数量（每个 1 GB多）（默认值：1）<br><code>--ethash.dagsondisk value</code>             硬盘中最近使用的 <code>ethash</code> 挖矿 <code>DAG</code> 的数量（每个 1 GB多）（默认值：2)</li>
<li>交易池选项：<br><code>--txpool.nolocals</code>                        禁止本地提交的交易价格豁免（？？？）<br><code>--txpool.journal value</code>                节点重新启动时要使用到的本地事务的磁盘日志（默认值：“transactions.rlp”）<br><code>--txpool.rejournal value</code>                重新生成本地事务日志的时间间隔（默认值：1h0m0s）<br><code>--txpool.pricelimit value</code>                被交易池所接受的最小 <code>gas</code> 限制（默认 1）<br><code>--txpool.pricebump value</code>                价格颠簸百分比替换已经存在的交易（默认值：10）(???)<br><code>--txpool.accountslots value</code>            每个账户保证可执行交易时间的最小数量（默认值：16）<br><code>--txpool.globalslots value</code>            所有帐户的可执行事务处理槽的最大数量（默认：4096）<br><code>--txpool.accountqueue value</code>            每个帐户允许的最大不可执行事务处理槽数（默认值：64）<br><code>--txpool.globalqueue value</code>            所有帐户允许的最大不可执行事务处理槽数（默认值：64）<br><code>--txpool.lifetime value</code>                不可执行事务排队的最长时间（默认值：3h0m0s）</li>
<li>性能调整选项：<br><code>--cache value</code>                兆字节的内存分配（最小16MB /数据库强制）（默认值：128）<br><code>--trie-cache-gens value</code>    保留在内存中的节点代数（默认值：120）</li>
<li>账户选项<br><code>--unlock value</code>            解锁以逗号分隔的帐户列表<br><code>--password value</code>            用来非交互密码输入的密码文件</li>
<li>API 和 控制台 选项：<br><code>--rpc</code>                     开启 <code>HTTP-RPC</code> 服务器<br><code>--rpcaddr value</code>        <code>HTTP-RPC</code> 服务器监听的地址（默认：<code>localhost</code>）<br><code>--rpcport value</code>        <code>HTTP-RPC</code> 服务器监听的端口（默认：8545）<br><code>--rpcapi value</code>        通过 <code>HTTP-RPC</code> 接口提供的 <code>API</code><br><code>--ws</code>                    开启 <code>WS-RPC</code> 服务器<br><code>--wsaddr value</code>        <code>WS-RPC</code> 服务器监听的地址（默认：<code>localhost</code>）<br><code>--wsport value</code>        <code>WS-RPC</code> 服务器监听的端口（默认：8546）<br><code>--wsapi value</code>            通过 <code>WS-RPC</code> 接口提供的 <code>API</code><br><code>--wsorigins value</code>        接受 <code>websockets</code> 请求的来源<br><code>--ipcdisable</code>            关闭 <code>IPC-RPC</code> 服务器<br><code>--ipcpath</code>                在 <code>datadir</code> 内的 <code>IPC socket/pipe</code> 文件名<br><code>--rpccorsdomain value</code> 以逗号分隔的接受跨源请求的域列表（浏览器强制执行）<br><code>--jspath loadScript</code>    加载脚本的 <code>JavaScript</code> 根目录（默认 : ‘.’）<br><code>--exec value</code>            执行 <code>JavaScript</code> 语句<br><code>--preload value</code>        预加载到控制台中以逗号分隔的 <code>JavaScript</code> 文件列表</li>
<li>网络选项<br><code>--bootnodes value</code>        用于 <code>P2P</code> 发现引导的逗号分隔的 <code>enode URL</code>（为轻服务器设置v4 + v5）<br><code>--bootnodesv4 value</code>    用于 <code>P2P v4</code> 发现引导程序的逗号分隔 <code>enode URL</code>（轻服务器，完整节点）<br><code>--bootnodesv5 value</code>    用于 <code>P2P v5</code> 发现引导的逗号分隔的 <code>enode URL</code>（轻服务器，轻节点）<br><code>--port value</code>            网络监听端口号（默认 30303）<br><code>--maxpeers value</code>        网络节点的最大数量（如果设为 0，则关闭网络连接）（默认 25）<br><code>--maxpendpeers value</code>    最大数量的挂起连接尝试（如果设为 0，使用默认值）（默认 0）<br><code>--nat value</code>            <code>NAT</code> 端口映射机制（<code>any | none | upnp | pmp | extip：&lt;IP&gt;</code>）（默认值：“any”）<br><code>--nodiscover</code>            关闭节点发现机制（手动添加节点）<br><code>--v5disc</code>                启用实验性RLPx V5（主题发现）机制<br><code>--netrestrict value</code>    将网络通信限制在给定的IP网络（CIDR掩码）<br><code>--nodekey value</code>        <code>P2P</code> 节点键文件<br><code>--nodekeyhex value</code>    <code>P2P</code> 节点 16 进制键（测试）</li>
<li>挖矿选项<br><code>--mine</code>                    开启挖矿<br><code>--minerthreads value</code>        用来挖矿的 <code>CPU</code> 数量（默认 1）<br><code>--etherbase value</code>            块挖掘奖励的公开地址（默认=创建的第一个帐户）（默认值：“0”）<br><code>--targetgaslimit value</code>     手动设置挖矿的区块的 <code>gas</code> 下限<br><code>--gasprice &quot;18000000000&quot;</code>    挖矿打包交易的最小 <code>gas</code> 价格<br><code>--extradata value</code>            矿工对区块设置的额外数据（默认是客户端版本）</li>
<li><code>gas price</code> 预设选项：<br><code>--gpoblocks value</code>            最近检测 <code>gas prices</code> 的区块数（默认是 10）<br><code>--gpopercentile value</code>        <code>gas price</code> 的推荐值是最近交易的 <code>gas price</code> 的一个集合的百分比</li>
<li>虚拟机选项：<br><code>--vmdebug</code>    记录对虚拟机和合约调试有用的信息</li>
<li>日志和调试选项<br><code>--metrics</code>                    开启指标收集和报告<br><code>--fakepow</code>                    关闭工作量证明验证<br><code>--nocompaction</code>            导入后禁用数据库压缩<br><code>--verbosity value</code>            记录详细程度：0 =静默，1 =错误，2 =警告，3 =信息，4 =调试，5 =详细信息（默认值：3）<br><code>--vmodule value</code>            每个模块的详细程度：以逗号分隔的 <code>&lt;pattern&gt; = &lt;level&gt;</code> 列表（例如<code>eth / * = 5，p2p = 4</code>）<br><code>--backtrace value</code>            在特定的日志语句处请求堆栈跟踪（例如“block.go：271”）<br><code>--debug</code>                    在被调用站点的位置（文件和行号）前加上日志消息<br><code>--pprof</code>                    开启 <code>pprof HTTP</code> 服务器<br><code>--pprofaddr value</code>            <code>pprof HTTP</code> 服务器监听接口（默认：<code>127.0.0.1</code>）<br><code>--pprofport value</code>            <code>pprof HTTP</code> 服务器监听端口（默认6060）<br><code>--memprofilerate value</code>    以给定速率打开内存分析（默认值：524288）<br><code>--blockprofilerate value</code>    以给定的速率打开块分析（默认值：0）<br><code>--cpuprofile value</code>        将 <code>CPU</code> 的分析写入给定的文件<br><code>--trace value</code>                将执行跟踪写入给定的文件</li>
<li><code>whisper</code> (实验)选项：<br><code>--shh</code>                            开启 <code>whisper</code><br><code>--shh.maxmessagesize value</code>    最大接收消息大小（默认：1048576）<br><code>--shh.pow value</code>                最小 <code>POW</code> 接受值（默认：0.2）</li>
<li>废弃选项：<br><code>--fast</code>     开启通过状态下载来快速同步的功能<br><code>--light</code>    开启轻客户端模式</li>
<li><code>misc</code> 选项：<br><code>help, -h</code> 显示帮助</li>
</ul>
<h3 id="控制台操作"><a href="#控制台操作" class="headerlink" title="控制台操作"></a>控制台操作</h3><p>常用命令：</p>
<ul>
<li><code>personal.newAccount()</code>:创建账户；</li>
<li><code>personal.unlockAccout()</code>:解锁账户；</li>
<li><code>eth.accounts</code>：枚举系统中的账户；</li>
<li><code>eth.getBalance()</code>：查看账户余额，返回值的单位是 <code>Wei</code>（<code>Wei</code> 是以太坊中最小货币面额单位，类似比特币中的聪，<code>1 ether = 10^18 Wei</code>）；</li>
<li><code>eth.blockNumber</code>：列出区块总数；</li>
<li><code>eth.getTransaction()</code>：获取交易；</li>
<li><code>eth.getBlock()</code>：获取区块；</li>
<li><code>miner.start()</code>：开始挖矿；</li>
<li><code>miner.stop()</code>：停止挖矿；</li>
<li><code>web3.fromWei()</code>：<code>Wei</code> 换算成以太币；</li>
<li><code>web3.toWei()</code>：以太币换算成 <code>Wei</code>；</li>
<li><code>txpool.status</code>：交易池中的状态；</li>
<li><code>admin.addPeer()</code>：连接到其他节点；</li>
<li><code>personal</code><ol>
<li><code>properties</code>:<br>1.1 <code>listAccounts</code>:账户列表<br>2.2 <code>listWallets</code>: 钱包列表<br>​    <code>accounts</code>：账户<br>​    <code>status</code>：状态<br>​    <code>url</code>：位置</li>
<li><code>functions</code>:<br>2.1 <code>deriveAccount : function()</code><br>2.2 <code>ecRecover : function()</code><br>2.3 <code>getListAccounts ：function(callback)</code> 获取账户列表<br>2.4 <code>getListWallets ：function(callback)</code> 获取钱包列表<br>2.5<code>importRawKey : function(callback)</code><br>2.6 <code>lockAccount ：function(callback)</code> 账户加锁<br>2.7 <code>newAccount ：function github.com/ethereum/go-ethereum/console.(*bridge).NewAccount-fm()</code> 账户创建<br>2.8<code>openWallet ：function github.com/ethereum/go-ethereum/console.(*bridge).OpenWallet-fm()</code><br>2.9 <code>sendTransaction ：function()</code> 发送交易<br>3.0 <code>sign ：function github.com/ethereum/go-ethereum/console.(*bridge).Sign-fm()</code> 签名<br>3.1 <code>unlockAccount ：function github.com/ethereum/go-ethereum/console.(*bridge).UnlockAccount-fm()</code> 账户解锁</li>
</ol>
</li>
<li>eth<br>1.1 accounts ： 账户<br>1.2 blockNumber ： 区块数<br>1.3 coinbase ： 挖矿所得账户<br>1.4 compile :<br>​        funciton:<br>​        lll : function()<br>​        serpent : function()<br>​        solidity : function()<br>1.5 defaultAccount ： 默认账户<br>1.6 defaultBlock: 默认区块<br>1.7 gasPrice ： 燃料价格<br>1.8 hashrate ：<br>1.9 mining ：<br>1.10 pendingTransactions ： 本地的以太坊节点拥有，并没有被打包入区块存储的交易，<br>1.11 protocolVersion :<br>1.12 syncing :<br>1.13 call : function()<br>1.14 contract : function(abi)<br>1.15 estimateGas : function()<br>1.16 filter : function(options, callback, filterCreationErrorCallback)<br>1.17 getAccounts: function(callback) 获取账户<br>1.18 getBalance: function(),<br>1.19 getBlock: function(),<br>1.20 getBlockNumber: function(callback),<br>1.21 getBlockTransactionCount: function(),<br>1.22 getBlockUncleCount: function(),<br>1.23 getCode: function(),<br>1.24 getCoinbase: function(callback),<br>1.25 getCompilers: function(),<br>1.26 getGasPrice: function(callback),<br>1.27 getHashrate: function(callback),<br>1.28 getMining: function(callback),<br>1.29 getPendingTransactions: function(callback),<br>1.30 getProtocolVersion: function(callback),<br>1.31 getRawTransaction: function(),<br>1.32 getRawTransactionFromBlock: function(),<br>1.33 getStorageAt: function(),<br>1.34 getSyncing: function(callback),<br>1.35 getTransaction: function(),<br>1.36 getTransactionCount: function(),<br>1.37 getTransactionFromBlock: function(),<br>1.38 getTransactionReceipt: function(),<br>1.39 getUncle: function(),<br>1.40 getWork: function(),<br>1.41 iban: function(iban),<br>1.42 icapNamereg: function(),<br>1.43 isSyncing: function(callback),<br>1.44 namereg: function(),<br>1.45 resend: function(),<br>1.46 sendIBANTransaction: function(),<br>1.47 sendRawTransaction: function(),<br>1.48 sendTransaction: function(),<br>1.49 sign: function(),<br>1.50 signTransaction: function(),<br>1.51 submitTransaction: function(),<br>1.52 submitWork: function()</li>
<li>miner<br>1.1  getHashrate: function(),<br>1.2     setEtherbase: function(),<br>1.3  setExtra: function(),<br>1.4     setGasPrice: function(),<br>1.5     start: function() 开启挖矿<br>1.6     stop: function() 停止挖矿</li>
<li>txpool<br>1.1 content:<br>​        pending:<br>​        queued:<br>1.2 inspect:<br>​        pending:<br>​        queued:<br>1.3 status:<br>​        pending:<br>​        queued:<br>1.4 getContent:function(callback)<br>1.5 getInspect:function(callback)<br>1.6 getStatus:function(callback)</li>
<li>admin<br>1.1 datadir: 区块链存储的目录<br>1.2 nodeInfo: 节点信息<br>​        enode: 被其他节点连接时用到的标识符，格式为 “enode://[id]@[ip]:[port]?param=value”<br>​        id: 节点唯一标识符<br>​        ip: 节点 ip<br>​        listenAddr: 节点监听的地址 “[ip]:[port]”<br>​        name: 节点名称<br>​        ports:<br>​            discovery: 是否允许被其他可连接的节点发现<br>​            listener: 监听的端口<br>​        protocols:<br>​            eth:<br>​                difficulty: 挖矿难度<br>​                genesis:<br>​                head<br>​                network<br>1.3 peers: 连接上的节点列表<br>1.4 addPeer: function() 添加节点<br>1.5 exportChain: function(),<br>1.6    getDatadir: function(callback),<br>1.7    getNodeInfo: function(callback),<br>1.8    getPeers: function(callback),<br>1.9    importChain: function(),<br>1.10 removePeer: function(),<br>1.11 sleep: <code>function github.com/ethereum/go-ethereum/console.(*bridge).Sleep-fm()</code>,<br>1.12 sleepBlocks: <code>function github.com/ethereum/go-ethereum/console.(*bridge).SleepBlocks-fm()</code> 在挖出指定数目的区块后停止<br>1.13 startRPC: function(),<br>1.14 startWS: function(),<br>1.15 stopRPC: function(),<br>1.16 stopWS: function()</li>
<li>web3<br>1.1 admin<br>1.2 bzz:<br>​        hive:<br>​        info:<br>​        blockNetworkRead: function(),<br>​        download: function(),<br>​        get: function(),<br>​        getHive: function(callback),<br>​        getInfo: function(callback),<br>​        modify: function(),<br>​        put: function(),<br>​        retrieve: function(),<br>​        store: function(),<br>​        swapEnabled: function(),<br>​        syncEnabled: function(),<br>​        upload: function()<br>1.3 currentProvider:<br>​        newAccount: function(),<br>​        openWallet: function(),<br>​        send: <code>function github.com/ethereum/go-ethereum/console.(*bridge).Send-fm()</code>,<br>​        sendAsync: <code>function github.com/ethereum/go-ethereum/console.(*bridge).Send-fm()</code>,<br>​        sign: function(),<br>​        unlockAccount: function()<br>1.4 db:<br>​        getHex: function(),<br>​        getString: function(),<br>​        putHex: function(),<br>​        putString: function()<br>1.5 debug:<br>​        backtraceAt: function(),<br>​        blockProfile: function(),<br>​        chaindbCompact: function(),<br>​        chaindbProperty: function(),<br>​        cpuProfile: function(),<br>​        dumpBlock: function(),<br>​        freeOSMemory: function(),<br>​        gcStats: function(),<br>​        getBadBlocks: function(),<br>​        getBlockRlp: function(),<br>​        getModifiedAccountsByHash: function(),<br>​        getModifiedAccountsByNumber: function(),<br>​        goTrace: function(),<br>​        memStats: function(),<br>​        metrics: function(),<br>​        preimage: function(),<br>​        printBlock: function(),<br>​        seedHash: function(),<br>​        setBlockProfileRate: function(),<br>​        setGCPercent: function(),<br>​        setHead: function(),<br>​        stacks: function(),<br>​        startCPUProfile: function(),<br>​        startGoTrace: function(),<br>​        stopCPUProfile: function(),<br>​        stopGoTrace: function(),<br>​        storageRangeAt: function(),<br>​        traceBlock: function(),<br>​        traceBlockByHash: function(),<br>​        traceBlockByNumber: function(),<br>​        traceBlockFromFile: function(),<br>​        traceTransaction: function(),<br>​        verbosity: function(),<br>​        vmodule: function(),<br>​        writeBlockProfile: function(),<br>​        writeMemProfile: function()<br>1.6 eth<br>1.7 isIBAN<br>1.8 miner<br>1.9 net<br>​        listening: true,<br>​        peerCount: 已连接的节点数量<br>​        version: “1”,<br>​        getListening: function(callback),<br>​        getPeerCount: function(callback),<br>​        getVersion: function(callback)<br>1.10 personal<br>1.11 providers:<br>​        HttpProvider: function(host, timeout, user, password),<pre><code>IpcProvider: function(path, net)
</code></pre>  1.12 rpc:<pre><code>modules:
    admin: &quot;1.0&quot;,
</code></pre>​            debug: “1.0”,<br>​            eth: “1.0”,<br>​            miner: “1.0”,<br>​            net: “1.0”,<br>​            personal: “1.0”,<br>​            rpc: “1.0”,<br>​            txpool: “1.0”,<br>​            web3: “1.0”<br>​        getModules:  function(callback)<br>1.13 settings:<br>​        defaultAccount: <pre><code>defaultBlock: 
</code></pre>  1.14 shh:<br>​        addPrivateKey: function(),<br>​        addSymKey: function(),<br>​        deleteKeyPair: function(),<br>​        deleteSymKey: function(),<br>​        generateSymKeyFromPassword: function(),<br>​        getPrivateKey: function(),<br>​        getPublicKey: function(),<br>​        getSymKey: function(),<br>​        hasKeyPair: function(),<br>​        hasSymKey: function(),<br>​        info: function(),<br>​        markTrustedPeer: function(),<br>​        newKeyPair: function(),<br>​        newMessageFilter: function(options, callback, filterCreationErrorCallback),<br>​        newSymKey: function(),<br>​        post: function(),<br>​        setMaxMessageSize: function(),<br>​        setMinPoW: function(),<br>​        version: function()<br>1.15 txpool<br>1.16 version:<br>​        api: “0.20.1”,<br>​        ethereum: “0x3f”,<br>​        network: “1”,<br>​        node: “Geth/TestNode/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9”,<br>​        whisper: undefined,<br>​        getEthereum: function(callback),<br>​        getNetwork: function(callback),<br>​        getNode: function(callback),<br>​        getWhisper: function(callback)<br>1.17 BigNumber: function a(e,n),<br>1.18 createBatch: function(),<br>1.19 fromAscii: function(str),<br>1.20 fromDecimal: function(value),<br>1.21 fromICAP: function(icap),<br>1.22 fromUtf8: function(str),<br>1.23 fromWei: function(number, unit) Wei转换成以太币<br>1.24 isAddress: function(address),<br>1.25 isChecksumAddress: function(address),<br>1.26 isConnected: function(),<br>1.27 padLeft: function(string, chars, sign),<br>1.28 padRight: function(string, chars, sign),<br>1.29 reset: function(keepIsSyncing),<br>1.30 setProvider: function(provider),<br>1.31 sha3: function(string, options),<br>1.32 toAscii: function(hex),<br>1.33 toBigNumber: function(number),<br>1.34 toChecksumAddress: function(address),<br>1.35 toDecimal: function(value),<br>1.36 toHex: function(val), 转换成 16 进制<br>1.37 toUtf8: function(hex), 16 进制转换成 utf8<br>1.38 toWei: function(number, unit) 以太币转换成 Wei</li>
</ul>
<h4 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h4><p><code>personal.newAccount()</code></p>
<h4 id="获取账户列表中第一个账户的资产"><a href="#获取账户列表中第一个账户的资产" class="headerlink" title="获取账户列表中第一个账户的资产"></a>获取账户列表中第一个账户的资产</h4><p><code>eth.getBalance(eth.accounts[0])</code></p>
<h4 id="启动-停止挖矿"><a href="#启动-停止挖矿" class="headerlink" title="启动 / 停止挖矿"></a>启动 / 停止挖矿</h4><p><code>miner.start() / miner.stop()</code></p>
<p>在第一次开启挖矿时，首先会生成 DAG 文件。生成完毕后会开始挖矿。</p>
<p>挖矿收入自动进入矿工账户 <code>coinbase</code>，默认情况该账户是本地账户中的第一个账户，也可以通过 <code>miner.setEtherbase()</code> 手动设置</p>
<h4 id="转账"><a href="#转账" class="headerlink" title="转账"></a>转账</h4><p><code>personal.unlockAccount(eth.accounts[0])</code> 解锁要转出资产的账户</p>
<p><code>eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(5,&#39;ether&#39;)})</code>从第一个账户转账到第二个账户 5 个以太坊</p>
<p>交易会保存在本地交易池 <code>txpool</code> 中，用 <code>txpool.status</code> 命令可以看到本地交易池中有一个待确认的交易。</p>
<blockquote>
<p><code>eth.pendingTransactions</code> VS <code>eth.getBlock(&#39;pending&#39;).transactions</code></p>
<p>添加一个合约之后，<code>eth.pendingTransactions</code> 内有数据，<code>eth.getBlock(&#39;pending&#39;).transactions</code> 返回 <code>[]</code>。</p>
<p><code>eth.pendingTransactions</code> are the transactions that your local Geth node has, that haven’t been mined to a block.<br><code>eth.pendingTransactions</code> 是本地的以太坊节点拥有的交易，并没有被打包入区块存储。</p>
<p><code>eth.getBlock(&#39;pending&#39;)</code> is the current block your node is mining (or would be mining on). It is not a block that has been added to the blockchain.  <code>eth.getBlock(&#39;pending&#39;).transactions</code> are the transactions that are included in this hypothetical block.<br><code>eth.getBlock(&#39;pending&#39;)</code> 是你当前真正挖的区块。这是还未被添加入区块链的区块。<code>eth.getBlock(&#39;pending&#39;).transactions</code> 是被包含在一个假想的区块内的交易。<br>If you are sending a transaction, you will see it first in eth.pendingTransactions, before a miner includes it in a block.<br>如果你发起了一笔交易，你首先在 <code>eth.pendingTransactions</code> 内看到，然后是被挖掘除的新区块内。</p>
</blockquote>
<p>等待新区块挖出，该交易会被打包入该区块中。转账的两个账户的资产更新。</p>
<h3 id="查看交易"><a href="#查看交易" class="headerlink" title="查看交易"></a>查看交易</h3><p>通过交易 Hash 查看交易（Hash 值包含在上面交易返回值中）：<code>eth.getTransaction(&quot;hash&quot;)</code></p>
<h3 id="查看区块"><a href="#查看区块" class="headerlink" title="查看区块"></a>查看区块</h3><p>通过区块号查看区块：<code>eth.getBlock(4)</code></p>
<h3 id="连接其他节点"><a href="#连接其他节点" class="headerlink" title="连接其他节点"></a>连接其他节点</h3><p>同一个链中，即 <code>chainId</code> 相同，可以通过 <code>admin.addPeer()</code> 方法连接到其他节点。</p>
<p>通过 <code>admin.nodeInfo.enode</code> 获取一个节点的 <code>enode</code>。在另一个节点 <code>admin.addPeer(&quot;[刚刚获取的enode]&quot;)</code>。需要将 <code>enode</code> 中的 <code>ip</code> 替换成该节点的 <code>ip</code>，如果是同一台电脑，则不用修改。</p>
<p>通过 <code>admin.peers</code> 查看连接到的其他节点信息。</p>
<h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>合约就是一段算法，代码，可执行的脚本。</p>
<h4 id="创建和编译智能合约"><a href="#创建和编译智能合约" class="headerlink" title="创建和编译智能合约"></a>创建和编译智能合约</h4><ol>
<li><p>写一个合约脚本。</p>
</li>
<li><p><code>solc --bin contractFile.sol</code> 编译该合约获得 <code>EVM</code> 二进制码 <code>code</code>。</p>
</li>
<li><p><code>solc --abi contractFile.sol</code> 获得合约接口 <a href="https://bitshuo.com/topic/594a8c228e822fcb444317ec" target="_blank" rel="noopener"><code>abi</code></a>。</p>
</li>
<li><p>在 <code>geth</code> 控制台 </p>
<p>code = “0x[上面获得的 code]”<br>abi = [上面获得的 abi]d</p>
</li>
</ol>
<h4 id="部署智能合约"><a href="#部署智能合约" class="headerlink" title="部署智能合约"></a>部署智能合约</h4><ol>
<li><code>personal.unlockAccount(eth.accounts[0])</code> 解锁部署时用到的账户</li>
<li><code>contract = eth.contract(abi).new({from:eth.accounts[0],data:code,gas:1000000})</code> 发送部署合约的交易（可以直接通过 sendTransaction()部署合约：<code>eth.sendTransaction({from:eth.accounts[0],data:code})</code>）</li>
<li>可在本地交易池中查看到该交易。等待新区块出现，该交易会被确认打包，进入新区块。</li>
</ol>
<ul>
<li>如果智能合约有构造函数，在部署时需要传入初始值，<code>contact = eth.contract(abi).new(arg1, arg2, ...,{from: eth.accounts[0], data: evmCode})</code>。<a href="https://ethereum.gitbooks.io/frontier-guide/content/creating_contract.html" target="_blank" rel="noopener">Creating and deploying a contract</a></li>
</ul>
<h4 id="调用智能合约"><a href="#调用智能合约" class="headerlink" title="调用智能合约"></a>调用智能合约</h4><p><code>contract.[合约中的方法名称].sendTransaction([合约中方法对应的参数,..], {from:[消耗燃料的账户,就是谁调用了这个合约]})</code></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>智能合约就是一段部署到以太坊上的代码。部署的时候消耗以太币，调用的时候也消耗以太币。</p>
<h3 id="智能合约例子-投票选举"><a href="#智能合约例子-投票选举" class="headerlink" title="智能合约例子 - 投票选举"></a>智能合约例子 - 投票选举</h3><h4 id="创建合约脚本文件"><a href="#创建合约脚本文件" class="headerlink" title="创建合约脚本文件"></a>创建合约脚本文件</h4><p><a href="https://gist.github.com/luren5/84e531e75392765efbb7fde250d6c315" target="_blank" rel="noopener">例子代码来源</a></p>
<h4 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h4><ol>
<li><code>solc --bin Ballot.sol</code> 获得编译后的二进制码 <code>code</code></li>
<li><code>solc --abi Ballot.sol</code> 获得合约的 <code>json abi</code> （<code>Application Binary Interface</code> 应用二进制接口）<code>abi</code></li>
<li><code>geth --identity &#39;NodeName&#39; --datadir datadir --... console</code> 进入控制台</li>
<li><code>code = &quot;0xcode&quot;</code> 右侧的 <code>code</code> 为第一步的 <code>code</code></li>
<li><code>abi = abi</code> 右侧的 <code>abi</code> 为第二部的 <code>abi</code></li>
<li><code>personal.unlockAccount(eth.accounts[0])</code> 解锁部署时要用到的账户，这里使用第一个账户</li>
<li><code>Ballot = eth.contract(abi)</code> 创建一个合约实例</li>
<li><code>myBallot = Ballot.new([&#39;f&#39;,&#39;y&#39;,&#39;k&#39;],{from:eth.account[0],data:code,gas:1000000})</code> 提交合约交易。<code>[&#39;f&#39;,&#39;y&#39;,&#39;k&#39;]</code>这个数组是合约的构造方法需要的数据。<a href="https://ethereum.gitbooks.io/frontier-guide/content/creating_contract.html" target="_blank" rel="noopener">语法</a></li>
<li><code>txpool.status</code> 中 <code>pending：1</code></li>
<li><code>miner.start()</code> 挖矿出块，合约被部署到区块链上了</li>
<li><code>personal.newAccount()</code> 创建几个新的账户</li>
<li><code>eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[i],value:web3.toWei(1,&#39;ether&#39;)})</code> 转一些资产到刚刚新创建的账户中。挖矿出块，资产转移成功。</li>
<li><code>myBallot.giveRightToVoter.sendTransaction(eth.account[i],&#39;name&#39;,{from:eth.accounts[0]})</code> 投票由第一个账户发起，所以是主持人。这里将之前创建的新账户赋予投票权，名字。挖矿出块，交易部署到区块链上。</li>
<li><code>myBallot.vote.sendTransaction(i,{from:eth.accounts[j],gas:470000})</code> 第 j 个账户投票给第 i+1 个人。因为索引是从 0 开始。挖矿出块。投票成功。投票前要对相应的账户进行解锁。包括上面赋权的操作，每一笔交易都需要对相应的账户解锁。</li>
<li><code>myBallot.voters(eth.account[i]);web3.toUtf8(&#39;namebin&#39;)</code> 获得第 i+1 个投票人的信息。将投票人的姓名的 16 进制字符串通过 <code>web3.toUtf8(&#39;namebin&#39;)</code> 来转换，可以看到姓名。</li>
<li><code>myBallot.winnerName.call();web3.toUtf8(&#39;namebin&#39;)</code> 可以看到获胜者的姓名</li>
<li><code>myBallot.proposals(i); web3.toUtf8(&#39;bin&#39;)</code> 可以看到被选举人的姓名，和票数</li>
</ol>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol>
<li><code>Ballot</code> 和 <code>myBallot</code> 的差别（<code>eth.contract()</code> 和 <code>eth.contract.new()</code>）</li>
</ol>
<p><a href="http://web3.tryblockchain.org/Web3.js-api-refrence.html#toc_51" target="_blank" rel="noopener">web3.eth.contract(abiArray)</a></p>
<p>创建一个Solidity的合约对象，可以被用来在某个地址上初始化合约。</p>
<p>参数：</p>
<p>Array - 一到多个描述合约的函数，事件的ABI对象。<br>返回值：</p>
<p>Object - 一个合约对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个合约对象</span><br><span class="line">var MyContract = web3.eth.contract(abiArray);</span><br><span class="line"></span><br><span class="line">// instantiate by address 在指定地址上初始化该对象</span><br><span class="line">var contractInstance = MyContract.at([address]);</span><br><span class="line"></span><br><span class="line">// deploy new contract 部署一个新合约</span><br><span class="line">var contractInstance = MyContract.new([contructorParam1] [, contructorParam2], &#123;data: &apos;0x12345...&apos;, from: myAccount, gas: 1000000&#125;);</span><br><span class="line"></span><br><span class="line">// Get the data to deploy the contract manually 获取数据用来手动部署合约</span><br><span class="line">var contractData = MyContract.new.getData([contructorParam1] [, contructorParam2], &#123;data: &apos;0x12345...&apos;&#125;);</span><br><span class="line">// contractData = &apos;0x12345643213456000000000023434234&apos;</span><br></pre></td></tr></table></figure>
<p>a = eth.contract(abi) 是实例化一个合约对象。查看 a 可以看到它是一个合约的对象，也就是此时只与创建它时的 <code>abi</code> 相关（相当于创建了一个合约模版，包含了上链相关的操作方法，但还是存在于本地），而它的方法列表中则有两个方法：<code>at: function(address, callback)</code>/ <code>new: function()</code> 。<code>at()</code> 就是在指定的地址上实例化该合约对象，应该是相当于取得已部署的一个合约。而 <code>new()</code> 则是部署一个新合约，在部署完毕之后，会返回</p>
<ol start="2">
<li>何时使用 <code>gas</code><br><code>web3.eth.sendTransaction(transactionObject [, callback])</code><br>发送一个交易到网络。<br>参数：</li>
</ol>
<ul>
<li>Object - 要发送的交易对象。</li>
<li>from: String - 指定的发送者的地址。如果不指定，使用web3.eth.defaultAccount。</li>
<li>to: String - （可选）交易消息的目标地址，如果是合约创建，则不填.</li>
<li>value: Number|String|BigNumber - （可选）交易携带的货币量，以wei为单位。如果合约创建交易，则为初始的基金。</li>
<li>gas: Number|String|BigNumber - （可选）默认是自动，交易可使用的gas，未使用的gas会退回。</li>
<li>gasPrice: Number|String|BigNumber - （可选）默认是自动确定，交易的gas价格，默认是网络gas价格的平均值 。</li>
<li>data: String - （可选）或者包含相关数据的字节字符串，如果是合约创建，则是初始化要用到的代码。</li>
<li>nonce: Number - （可选）整数，使用此值，可以允许你覆盖你自己的相同nonce的，正在pending中的交易11。</li>
<li>Function - 回调函数，用于支持异步的方式执行7。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值：</span><br><span class="line">String - 32字节的交易哈希串。用16进制表示。</span><br><span class="line">fullhash=0x542fbb5848724a5ef7511ee2503d10c0180bd0b9eed5dd7a175bb84375250f09 recipient=0x5Bc642Cd76Bf742ef3d202824e1d258942205218</span><br><span class="line">fullhash 是交易哈希，recipient 是合约地址。</span><br></pre></td></tr></table></figure>
<p>上面参数中的 gas 就是你指定的燃料。即你愿意为该交易支付多少燃料。如果燃料不足以支撑交易的执行，那么该交易会回滚。如果交易未耗完燃料，剩余的燃料会回退。如果燃料给的太多，超过了区块的燃料限制，也会被拒绝。区块的燃料限制就是 genesis.json 内的 gas limit 参数。这个参数指定了这个区块最多消耗这么多燃料。</p>
<ol start="3">
<li>对合约对象的属性的调用。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Automatically determines the use of call or sendTransaction based on the method type</span><br><span class="line">myContractInstance.myMethod(param1 [, param2, ...][, transactionObject] [, defaultBlock][, callback]);</span><br><span class="line"></span><br><span class="line">// Explicitly calling this method</span><br><span class="line">myContractInstance.myMethod.call(param1 [, param2, ...] [, transactionObject] [, defaultBlock] [, callback]);</span><br><span class="line"></span><br><span class="line">// Explicitly sending a transaction to this method</span><br><span class="line">myContractInstance.myMethod.sendTransaction(param1 [, param2, ...] [, transactionObject] [, callback]);</span><br><span class="line"></span><br><span class="line">// Get the call data, so you can call the contract through some other means</span><br><span class="line">var myCallData = myContractInstance.myMethod.getData(param1 [, param2, ...]);</span><br><span class="line">// myCallData = &apos;0x45ff3ff6000000000004545345345345..&apos;</span><br></pre></td></tr></table></figure>
<p>合约对象内封装了使用合约的相关方法。可以通过传入参数，和交易对象来使用方法。</p>
<p>参数：</p>
<p>String|Number - （可选）零或多个函数参数。如果传入一个字符串，需要使用十六进制编码，如，0xdedbeef。<br>Object - （可选）最后一个参数（如果传了callback，则是倒数第二个参数），可以是一个交易对象。查看web3.eth.sendTransaction的第一个参数说明来了解更多。注意，这里不需要填data和to属性。<br>Number|String -（可选）如果不设置此值使用web3.eth.defaultBlock设定的块，否则使用指定的块。<br>Function -（可选）回调函数，用于支持异步的方式执行7。<br>返回值：</p>
<p>String - 如果发起的是一个 <code>call</code>，对应的是返回结果。如果是 <code>transaction</code>，则要么是一个创建的合约地址，或者是一个 <code>transaction</code> 的哈希值。查看 <code>web3.eth.sendTransaction</code> 了解更多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// creation of contract object</span><br><span class="line">var MyContract = web3.eth.contract(abi);</span><br><span class="line"></span><br><span class="line">// initiate contract for an address</span><br><span class="line">var myContractInstance = MyContract.at(&apos;0x78e97bcc5b5dd9ed228fed7a4887c0d7287344a9&apos;);</span><br><span class="line"></span><br><span class="line">var result = myContractInstance.myConstantMethod(&apos;myParam&apos;);</span><br><span class="line">console.log(result) // &apos;0x25434534534&apos;</span><br><span class="line"></span><br><span class="line">myContractInstance.myStateChangingMethod(&apos;someParam1&apos;, 23, &#123;value: 200, gas: 2000&#125;, function(err, result)&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p>对于不会改变合约状态的合约函数的调用，直接使用 call 即可。</p>
<ol start="4">
<li>合约的事件 event 是什么? event 中的 indexed 是什么？</li>
</ol>
<p><a href="http://me.tryblockchain.org/blockchain-solidity-event.html" target="_blank" rel="noopener">Solidity的event事件（二十一）|入门系列</a></p>
<p><a href="http://me.tryblockchain.org/Blockchain-event-bestpractice.html" target="_blank" rel="noopener">Solidity的event的支持指引（二十二）|入门系列</a></p>
<ol start="5">
<li>modifier 是什么</li>
</ol>
<p>修饰器（Modifier）是一个简便的途径用来验证函数输入的有效性。类似于校验器，单独封装好，然后被方法调用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
